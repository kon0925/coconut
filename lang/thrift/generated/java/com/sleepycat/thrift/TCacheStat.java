/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.sleepycat.thrift;

import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import org.apache.thrift.async.AsyncMethodCallback;
import org.apache.thrift.server.AbstractNonblockingServer.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import javax.annotation.Generated;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
@Generated(value = "Autogenerated by Thrift Compiler (0.9.2)", date = "2015-10-9")
public class TCacheStat implements org.apache.thrift.TBase<TCacheStat, TCacheStat._Fields>, java.io.Serializable, Cloneable, Comparable<TCacheStat> {
  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TCacheStat");

  private static final org.apache.thrift.protocol.TField ALLOC_FIELD_DESC = new org.apache.thrift.protocol.TField("alloc", org.apache.thrift.protocol.TType.I64, (short)1);
  private static final org.apache.thrift.protocol.TField ALLOC_BUCKETS_FIELD_DESC = new org.apache.thrift.protocol.TField("allocBuckets", org.apache.thrift.protocol.TType.I64, (short)2);
  private static final org.apache.thrift.protocol.TField ALLOC_MAX_BUCKETS_FIELD_DESC = new org.apache.thrift.protocol.TField("allocMaxBuckets", org.apache.thrift.protocol.TType.I64, (short)3);
  private static final org.apache.thrift.protocol.TField ALLOC_MAX_PAGES_FIELD_DESC = new org.apache.thrift.protocol.TField("allocMaxPages", org.apache.thrift.protocol.TType.I64, (short)4);
  private static final org.apache.thrift.protocol.TField ALLOC_PAGES_FIELD_DESC = new org.apache.thrift.protocol.TField("allocPages", org.apache.thrift.protocol.TType.I64, (short)5);
  private static final org.apache.thrift.protocol.TField BYTES_FIELD_DESC = new org.apache.thrift.protocol.TField("bytes", org.apache.thrift.protocol.TType.I32, (short)6);
  private static final org.apache.thrift.protocol.TField CACHE_HIT_FIELD_DESC = new org.apache.thrift.protocol.TField("cacheHit", org.apache.thrift.protocol.TType.I64, (short)7);
  private static final org.apache.thrift.protocol.TField CACHE_MISS_FIELD_DESC = new org.apache.thrift.protocol.TField("cacheMiss", org.apache.thrift.protocol.TType.I64, (short)8);
  private static final org.apache.thrift.protocol.TField GBYTES_FIELD_DESC = new org.apache.thrift.protocol.TField("gbytes", org.apache.thrift.protocol.TType.I32, (short)9);
  private static final org.apache.thrift.protocol.TField HASH_BUCKETS_FIELD_DESC = new org.apache.thrift.protocol.TField("hashBuckets", org.apache.thrift.protocol.TType.I32, (short)10);
  private static final org.apache.thrift.protocol.TField HASH_EXAMINED_FIELD_DESC = new org.apache.thrift.protocol.TField("hashExamined", org.apache.thrift.protocol.TType.I64, (short)11);
  private static final org.apache.thrift.protocol.TField HASH_LONGEST_FIELD_DESC = new org.apache.thrift.protocol.TField("hashLongest", org.apache.thrift.protocol.TType.I32, (short)12);
  private static final org.apache.thrift.protocol.TField HASH_MAX_NOWAIT_FIELD_DESC = new org.apache.thrift.protocol.TField("hashMaxNowait", org.apache.thrift.protocol.TType.I64, (short)13);
  private static final org.apache.thrift.protocol.TField HASH_MAX_WAIT_FIELD_DESC = new org.apache.thrift.protocol.TField("hashMaxWait", org.apache.thrift.protocol.TType.I64, (short)14);
  private static final org.apache.thrift.protocol.TField HASH_MUTEXES_FIELD_DESC = new org.apache.thrift.protocol.TField("hashMutexes", org.apache.thrift.protocol.TType.I32, (short)15);
  private static final org.apache.thrift.protocol.TField HASH_NOWAIT_FIELD_DESC = new org.apache.thrift.protocol.TField("hashNowait", org.apache.thrift.protocol.TType.I64, (short)16);
  private static final org.apache.thrift.protocol.TField HASH_SEARCHES_FIELD_DESC = new org.apache.thrift.protocol.TField("hashSearches", org.apache.thrift.protocol.TType.I32, (short)17);
  private static final org.apache.thrift.protocol.TField HASH_WAIT_FIELD_DESC = new org.apache.thrift.protocol.TField("hashWait", org.apache.thrift.protocol.TType.I64, (short)18);
  private static final org.apache.thrift.protocol.TField IO_WAIT_FIELD_DESC = new org.apache.thrift.protocol.TField("ioWait", org.apache.thrift.protocol.TType.I64, (short)19);
  private static final org.apache.thrift.protocol.TField MAX_NUM_CACHE_FIELD_DESC = new org.apache.thrift.protocol.TField("maxNumCache", org.apache.thrift.protocol.TType.I32, (short)20);
  private static final org.apache.thrift.protocol.TField MAX_OPENFD_FIELD_DESC = new org.apache.thrift.protocol.TField("maxOpenfd", org.apache.thrift.protocol.TType.I32, (short)21);
  private static final org.apache.thrift.protocol.TField MAX_WRITE_FIELD_DESC = new org.apache.thrift.protocol.TField("maxWrite", org.apache.thrift.protocol.TType.I32, (short)22);
  private static final org.apache.thrift.protocol.TField MAX_WRITE_SLEEP_FIELD_DESC = new org.apache.thrift.protocol.TField("maxWriteSleep", org.apache.thrift.protocol.TType.I32, (short)23);
  private static final org.apache.thrift.protocol.TField MMAP_SIZE_FIELD_DESC = new org.apache.thrift.protocol.TField("mmapSize", org.apache.thrift.protocol.TType.I64, (short)24);
  private static final org.apache.thrift.protocol.TField MULTIVERSION_FREED_FIELD_DESC = new org.apache.thrift.protocol.TField("multiversionFreed", org.apache.thrift.protocol.TType.I64, (short)25);
  private static final org.apache.thrift.protocol.TField MULTIVERSION_FROZEN_FIELD_DESC = new org.apache.thrift.protocol.TField("multiversionFrozen", org.apache.thrift.protocol.TType.I64, (short)26);
  private static final org.apache.thrift.protocol.TField MULTIVERSION_REUSED_FIELD_DESC = new org.apache.thrift.protocol.TField("multiversionReused", org.apache.thrift.protocol.TType.I64, (short)27);
  private static final org.apache.thrift.protocol.TField MULTIVERSION_THAWED_FIELD_DESC = new org.apache.thrift.protocol.TField("multiversionThawed", org.apache.thrift.protocol.TType.I64, (short)28);
  private static final org.apache.thrift.protocol.TField NUM_CACHE_FIELD_DESC = new org.apache.thrift.protocol.TField("numCache", org.apache.thrift.protocol.TType.I32, (short)29);
  private static final org.apache.thrift.protocol.TField PAGES_FIELD_DESC = new org.apache.thrift.protocol.TField("pages", org.apache.thrift.protocol.TType.I32, (short)30);
  private static final org.apache.thrift.protocol.TField PAGE_SIZE_FIELD_DESC = new org.apache.thrift.protocol.TField("pageSize", org.apache.thrift.protocol.TType.I32, (short)31);
  private static final org.apache.thrift.protocol.TField PAGE_CLEAN_FIELD_DESC = new org.apache.thrift.protocol.TField("pageClean", org.apache.thrift.protocol.TType.I32, (short)32);
  private static final org.apache.thrift.protocol.TField PAGE_CREATE_FIELD_DESC = new org.apache.thrift.protocol.TField("pageCreate", org.apache.thrift.protocol.TType.I64, (short)33);
  private static final org.apache.thrift.protocol.TField PAGE_DIRTY_FIELD_DESC = new org.apache.thrift.protocol.TField("pageDirty", org.apache.thrift.protocol.TType.I32, (short)34);
  private static final org.apache.thrift.protocol.TField PAGE_MAPPED_FIELD_DESC = new org.apache.thrift.protocol.TField("pageMapped", org.apache.thrift.protocol.TType.I32, (short)35);
  private static final org.apache.thrift.protocol.TField PAGE_IN_FIELD_DESC = new org.apache.thrift.protocol.TField("pageIn", org.apache.thrift.protocol.TType.I64, (short)36);
  private static final org.apache.thrift.protocol.TField PAGE_TRICKLE_FIELD_DESC = new org.apache.thrift.protocol.TField("pageTrickle", org.apache.thrift.protocol.TType.I64, (short)37);
  private static final org.apache.thrift.protocol.TField PAGE_OUT_FIELD_DESC = new org.apache.thrift.protocol.TField("pageOut", org.apache.thrift.protocol.TType.I64, (short)38);
  private static final org.apache.thrift.protocol.TField REGION_NOWAIT_FIELD_DESC = new org.apache.thrift.protocol.TField("regionNowait", org.apache.thrift.protocol.TType.I64, (short)39);
  private static final org.apache.thrift.protocol.TField REGION_WAIT_FIELD_DESC = new org.apache.thrift.protocol.TField("regionWait", org.apache.thrift.protocol.TType.I64, (short)40);
  private static final org.apache.thrift.protocol.TField REGMAX_FIELD_DESC = new org.apache.thrift.protocol.TField("regmax", org.apache.thrift.protocol.TType.I64, (short)41);
  private static final org.apache.thrift.protocol.TField REG_SIZE_FIELD_DESC = new org.apache.thrift.protocol.TField("regSize", org.apache.thrift.protocol.TType.I64, (short)42);
  private static final org.apache.thrift.protocol.TField RO_EVICT_FIELD_DESC = new org.apache.thrift.protocol.TField("roEvict", org.apache.thrift.protocol.TType.I64, (short)43);
  private static final org.apache.thrift.protocol.TField RW_EVICT_FIELD_DESC = new org.apache.thrift.protocol.TField("rwEvict", org.apache.thrift.protocol.TType.I64, (short)44);
  private static final org.apache.thrift.protocol.TField SYNC_INTERRUPTED_FIELD_DESC = new org.apache.thrift.protocol.TField("syncInterrupted", org.apache.thrift.protocol.TType.I64, (short)45);

  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
  static {
    schemes.put(StandardScheme.class, new TCacheStatStandardSchemeFactory());
    schemes.put(TupleScheme.class, new TCacheStatTupleSchemeFactory());
  }

  public long alloc; // required
  public long allocBuckets; // required
  public long allocMaxBuckets; // required
  public long allocMaxPages; // required
  public long allocPages; // required
  public int bytes; // required
  public long cacheHit; // required
  public long cacheMiss; // required
  public int gbytes; // required
  public int hashBuckets; // required
  public long hashExamined; // required
  public int hashLongest; // required
  public long hashMaxNowait; // required
  public long hashMaxWait; // required
  public int hashMutexes; // required
  public long hashNowait; // required
  public int hashSearches; // required
  public long hashWait; // required
  public long ioWait; // required
  public int maxNumCache; // required
  public int maxOpenfd; // required
  public int maxWrite; // required
  public int maxWriteSleep; // required
  public long mmapSize; // required
  public long multiversionFreed; // required
  public long multiversionFrozen; // required
  public long multiversionReused; // required
  public long multiversionThawed; // required
  public int numCache; // required
  public int pages; // required
  public int pageSize; // required
  public int pageClean; // required
  public long pageCreate; // required
  public int pageDirty; // required
  public int pageMapped; // required
  public long pageIn; // required
  public long pageTrickle; // required
  public long pageOut; // required
  public long regionNowait; // required
  public long regionWait; // required
  public long regmax; // required
  public long regSize; // required
  public long roEvict; // required
  public long rwEvict; // required
  public long syncInterrupted; // required

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
    ALLOC((short)1, "alloc"),
    ALLOC_BUCKETS((short)2, "allocBuckets"),
    ALLOC_MAX_BUCKETS((short)3, "allocMaxBuckets"),
    ALLOC_MAX_PAGES((short)4, "allocMaxPages"),
    ALLOC_PAGES((short)5, "allocPages"),
    BYTES((short)6, "bytes"),
    CACHE_HIT((short)7, "cacheHit"),
    CACHE_MISS((short)8, "cacheMiss"),
    GBYTES((short)9, "gbytes"),
    HASH_BUCKETS((short)10, "hashBuckets"),
    HASH_EXAMINED((short)11, "hashExamined"),
    HASH_LONGEST((short)12, "hashLongest"),
    HASH_MAX_NOWAIT((short)13, "hashMaxNowait"),
    HASH_MAX_WAIT((short)14, "hashMaxWait"),
    HASH_MUTEXES((short)15, "hashMutexes"),
    HASH_NOWAIT((short)16, "hashNowait"),
    HASH_SEARCHES((short)17, "hashSearches"),
    HASH_WAIT((short)18, "hashWait"),
    IO_WAIT((short)19, "ioWait"),
    MAX_NUM_CACHE((short)20, "maxNumCache"),
    MAX_OPENFD((short)21, "maxOpenfd"),
    MAX_WRITE((short)22, "maxWrite"),
    MAX_WRITE_SLEEP((short)23, "maxWriteSleep"),
    MMAP_SIZE((short)24, "mmapSize"),
    MULTIVERSION_FREED((short)25, "multiversionFreed"),
    MULTIVERSION_FROZEN((short)26, "multiversionFrozen"),
    MULTIVERSION_REUSED((short)27, "multiversionReused"),
    MULTIVERSION_THAWED((short)28, "multiversionThawed"),
    NUM_CACHE((short)29, "numCache"),
    PAGES((short)30, "pages"),
    PAGE_SIZE((short)31, "pageSize"),
    PAGE_CLEAN((short)32, "pageClean"),
    PAGE_CREATE((short)33, "pageCreate"),
    PAGE_DIRTY((short)34, "pageDirty"),
    PAGE_MAPPED((short)35, "pageMapped"),
    PAGE_IN((short)36, "pageIn"),
    PAGE_TRICKLE((short)37, "pageTrickle"),
    PAGE_OUT((short)38, "pageOut"),
    REGION_NOWAIT((short)39, "regionNowait"),
    REGION_WAIT((short)40, "regionWait"),
    REGMAX((short)41, "regmax"),
    REG_SIZE((short)42, "regSize"),
    RO_EVICT((short)43, "roEvict"),
    RW_EVICT((short)44, "rwEvict"),
    SYNC_INTERRUPTED((short)45, "syncInterrupted");

    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // ALLOC
          return ALLOC;
        case 2: // ALLOC_BUCKETS
          return ALLOC_BUCKETS;
        case 3: // ALLOC_MAX_BUCKETS
          return ALLOC_MAX_BUCKETS;
        case 4: // ALLOC_MAX_PAGES
          return ALLOC_MAX_PAGES;
        case 5: // ALLOC_PAGES
          return ALLOC_PAGES;
        case 6: // BYTES
          return BYTES;
        case 7: // CACHE_HIT
          return CACHE_HIT;
        case 8: // CACHE_MISS
          return CACHE_MISS;
        case 9: // GBYTES
          return GBYTES;
        case 10: // HASH_BUCKETS
          return HASH_BUCKETS;
        case 11: // HASH_EXAMINED
          return HASH_EXAMINED;
        case 12: // HASH_LONGEST
          return HASH_LONGEST;
        case 13: // HASH_MAX_NOWAIT
          return HASH_MAX_NOWAIT;
        case 14: // HASH_MAX_WAIT
          return HASH_MAX_WAIT;
        case 15: // HASH_MUTEXES
          return HASH_MUTEXES;
        case 16: // HASH_NOWAIT
          return HASH_NOWAIT;
        case 17: // HASH_SEARCHES
          return HASH_SEARCHES;
        case 18: // HASH_WAIT
          return HASH_WAIT;
        case 19: // IO_WAIT
          return IO_WAIT;
        case 20: // MAX_NUM_CACHE
          return MAX_NUM_CACHE;
        case 21: // MAX_OPENFD
          return MAX_OPENFD;
        case 22: // MAX_WRITE
          return MAX_WRITE;
        case 23: // MAX_WRITE_SLEEP
          return MAX_WRITE_SLEEP;
        case 24: // MMAP_SIZE
          return MMAP_SIZE;
        case 25: // MULTIVERSION_FREED
          return MULTIVERSION_FREED;
        case 26: // MULTIVERSION_FROZEN
          return MULTIVERSION_FROZEN;
        case 27: // MULTIVERSION_REUSED
          return MULTIVERSION_REUSED;
        case 28: // MULTIVERSION_THAWED
          return MULTIVERSION_THAWED;
        case 29: // NUM_CACHE
          return NUM_CACHE;
        case 30: // PAGES
          return PAGES;
        case 31: // PAGE_SIZE
          return PAGE_SIZE;
        case 32: // PAGE_CLEAN
          return PAGE_CLEAN;
        case 33: // PAGE_CREATE
          return PAGE_CREATE;
        case 34: // PAGE_DIRTY
          return PAGE_DIRTY;
        case 35: // PAGE_MAPPED
          return PAGE_MAPPED;
        case 36: // PAGE_IN
          return PAGE_IN;
        case 37: // PAGE_TRICKLE
          return PAGE_TRICKLE;
        case 38: // PAGE_OUT
          return PAGE_OUT;
        case 39: // REGION_NOWAIT
          return REGION_NOWAIT;
        case 40: // REGION_WAIT
          return REGION_WAIT;
        case 41: // REGMAX
          return REGMAX;
        case 42: // REG_SIZE
          return REG_SIZE;
        case 43: // RO_EVICT
          return RO_EVICT;
        case 44: // RW_EVICT
          return RW_EVICT;
        case 45: // SYNC_INTERRUPTED
          return SYNC_INTERRUPTED;
        default:
          return null;
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }

    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }

    private final short _thriftId;
    private final String _fieldName;

    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }

    public short getThriftFieldId() {
      return _thriftId;
    }

    public String getFieldName() {
      return _fieldName;
    }
  }

  // isset id assignments
  private static final int __ALLOC_ISSET_ID = 0;
  private static final int __ALLOCBUCKETS_ISSET_ID = 1;
  private static final int __ALLOCMAXBUCKETS_ISSET_ID = 2;
  private static final int __ALLOCMAXPAGES_ISSET_ID = 3;
  private static final int __ALLOCPAGES_ISSET_ID = 4;
  private static final int __BYTES_ISSET_ID = 5;
  private static final int __CACHEHIT_ISSET_ID = 6;
  private static final int __CACHEMISS_ISSET_ID = 7;
  private static final int __GBYTES_ISSET_ID = 8;
  private static final int __HASHBUCKETS_ISSET_ID = 9;
  private static final int __HASHEXAMINED_ISSET_ID = 10;
  private static final int __HASHLONGEST_ISSET_ID = 11;
  private static final int __HASHMAXNOWAIT_ISSET_ID = 12;
  private static final int __HASHMAXWAIT_ISSET_ID = 13;
  private static final int __HASHMUTEXES_ISSET_ID = 14;
  private static final int __HASHNOWAIT_ISSET_ID = 15;
  private static final int __HASHSEARCHES_ISSET_ID = 16;
  private static final int __HASHWAIT_ISSET_ID = 17;
  private static final int __IOWAIT_ISSET_ID = 18;
  private static final int __MAXNUMCACHE_ISSET_ID = 19;
  private static final int __MAXOPENFD_ISSET_ID = 20;
  private static final int __MAXWRITE_ISSET_ID = 21;
  private static final int __MAXWRITESLEEP_ISSET_ID = 22;
  private static final int __MMAPSIZE_ISSET_ID = 23;
  private static final int __MULTIVERSIONFREED_ISSET_ID = 24;
  private static final int __MULTIVERSIONFROZEN_ISSET_ID = 25;
  private static final int __MULTIVERSIONREUSED_ISSET_ID = 26;
  private static final int __MULTIVERSIONTHAWED_ISSET_ID = 27;
  private static final int __NUMCACHE_ISSET_ID = 28;
  private static final int __PAGES_ISSET_ID = 29;
  private static final int __PAGESIZE_ISSET_ID = 30;
  private static final int __PAGECLEAN_ISSET_ID = 31;
  private static final int __PAGECREATE_ISSET_ID = 32;
  private static final int __PAGEDIRTY_ISSET_ID = 33;
  private static final int __PAGEMAPPED_ISSET_ID = 34;
  private static final int __PAGEIN_ISSET_ID = 35;
  private static final int __PAGETRICKLE_ISSET_ID = 36;
  private static final int __PAGEOUT_ISSET_ID = 37;
  private static final int __REGIONNOWAIT_ISSET_ID = 38;
  private static final int __REGIONWAIT_ISSET_ID = 39;
  private static final int __REGMAX_ISSET_ID = 40;
  private static final int __REGSIZE_ISSET_ID = 41;
  private static final int __ROEVICT_ISSET_ID = 42;
  private static final int __RWEVICT_ISSET_ID = 43;
  private static final int __SYNCINTERRUPTED_ISSET_ID = 44;
  private long __isset_bitfield = 0;
  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
  static {
    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.ALLOC, new org.apache.thrift.meta_data.FieldMetaData("alloc", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.ALLOC_BUCKETS, new org.apache.thrift.meta_data.FieldMetaData("allocBuckets", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.ALLOC_MAX_BUCKETS, new org.apache.thrift.meta_data.FieldMetaData("allocMaxBuckets", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.ALLOC_MAX_PAGES, new org.apache.thrift.meta_data.FieldMetaData("allocMaxPages", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.ALLOC_PAGES, new org.apache.thrift.meta_data.FieldMetaData("allocPages", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.BYTES, new org.apache.thrift.meta_data.FieldMetaData("bytes", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.CACHE_HIT, new org.apache.thrift.meta_data.FieldMetaData("cacheHit", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.CACHE_MISS, new org.apache.thrift.meta_data.FieldMetaData("cacheMiss", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.GBYTES, new org.apache.thrift.meta_data.FieldMetaData("gbytes", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.HASH_BUCKETS, new org.apache.thrift.meta_data.FieldMetaData("hashBuckets", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.HASH_EXAMINED, new org.apache.thrift.meta_data.FieldMetaData("hashExamined", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.HASH_LONGEST, new org.apache.thrift.meta_data.FieldMetaData("hashLongest", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.HASH_MAX_NOWAIT, new org.apache.thrift.meta_data.FieldMetaData("hashMaxNowait", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.HASH_MAX_WAIT, new org.apache.thrift.meta_data.FieldMetaData("hashMaxWait", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.HASH_MUTEXES, new org.apache.thrift.meta_data.FieldMetaData("hashMutexes", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.HASH_NOWAIT, new org.apache.thrift.meta_data.FieldMetaData("hashNowait", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.HASH_SEARCHES, new org.apache.thrift.meta_data.FieldMetaData("hashSearches", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.HASH_WAIT, new org.apache.thrift.meta_data.FieldMetaData("hashWait", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.IO_WAIT, new org.apache.thrift.meta_data.FieldMetaData("ioWait", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.MAX_NUM_CACHE, new org.apache.thrift.meta_data.FieldMetaData("maxNumCache", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MAX_OPENFD, new org.apache.thrift.meta_data.FieldMetaData("maxOpenfd", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MAX_WRITE, new org.apache.thrift.meta_data.FieldMetaData("maxWrite", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MAX_WRITE_SLEEP, new org.apache.thrift.meta_data.FieldMetaData("maxWriteSleep", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MMAP_SIZE, new org.apache.thrift.meta_data.FieldMetaData("mmapSize", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.MULTIVERSION_FREED, new org.apache.thrift.meta_data.FieldMetaData("multiversionFreed", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.MULTIVERSION_FROZEN, new org.apache.thrift.meta_data.FieldMetaData("multiversionFrozen", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.MULTIVERSION_REUSED, new org.apache.thrift.meta_data.FieldMetaData("multiversionReused", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.MULTIVERSION_THAWED, new org.apache.thrift.meta_data.FieldMetaData("multiversionThawed", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.NUM_CACHE, new org.apache.thrift.meta_data.FieldMetaData("numCache", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.PAGES, new org.apache.thrift.meta_data.FieldMetaData("pages", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.PAGE_SIZE, new org.apache.thrift.meta_data.FieldMetaData("pageSize", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.PAGE_CLEAN, new org.apache.thrift.meta_data.FieldMetaData("pageClean", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.PAGE_CREATE, new org.apache.thrift.meta_data.FieldMetaData("pageCreate", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.PAGE_DIRTY, new org.apache.thrift.meta_data.FieldMetaData("pageDirty", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.PAGE_MAPPED, new org.apache.thrift.meta_data.FieldMetaData("pageMapped", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.PAGE_IN, new org.apache.thrift.meta_data.FieldMetaData("pageIn", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.PAGE_TRICKLE, new org.apache.thrift.meta_data.FieldMetaData("pageTrickle", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.PAGE_OUT, new org.apache.thrift.meta_data.FieldMetaData("pageOut", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.REGION_NOWAIT, new org.apache.thrift.meta_data.FieldMetaData("regionNowait", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.REGION_WAIT, new org.apache.thrift.meta_data.FieldMetaData("regionWait", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.REGMAX, new org.apache.thrift.meta_data.FieldMetaData("regmax", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.REG_SIZE, new org.apache.thrift.meta_data.FieldMetaData("regSize", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.RO_EVICT, new org.apache.thrift.meta_data.FieldMetaData("roEvict", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.RW_EVICT, new org.apache.thrift.meta_data.FieldMetaData("rwEvict", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.SYNC_INTERRUPTED, new org.apache.thrift.meta_data.FieldMetaData("syncInterrupted", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(TCacheStat.class, metaDataMap);
  }

  public TCacheStat() {
  }

  public TCacheStat(
    long alloc,
    long allocBuckets,
    long allocMaxBuckets,
    long allocMaxPages,
    long allocPages,
    int bytes,
    long cacheHit,
    long cacheMiss,
    int gbytes,
    int hashBuckets,
    long hashExamined,
    int hashLongest,
    long hashMaxNowait,
    long hashMaxWait,
    int hashMutexes,
    long hashNowait,
    int hashSearches,
    long hashWait,
    long ioWait,
    int maxNumCache,
    int maxOpenfd,
    int maxWrite,
    int maxWriteSleep,
    long mmapSize,
    long multiversionFreed,
    long multiversionFrozen,
    long multiversionReused,
    long multiversionThawed,
    int numCache,
    int pages,
    int pageSize,
    int pageClean,
    long pageCreate,
    int pageDirty,
    int pageMapped,
    long pageIn,
    long pageTrickle,
    long pageOut,
    long regionNowait,
    long regionWait,
    long regmax,
    long regSize,
    long roEvict,
    long rwEvict,
    long syncInterrupted)
  {
    this();
    this.alloc = alloc;
    setAllocIsSet(true);
    this.allocBuckets = allocBuckets;
    setAllocBucketsIsSet(true);
    this.allocMaxBuckets = allocMaxBuckets;
    setAllocMaxBucketsIsSet(true);
    this.allocMaxPages = allocMaxPages;
    setAllocMaxPagesIsSet(true);
    this.allocPages = allocPages;
    setAllocPagesIsSet(true);
    this.bytes = bytes;
    setBytesIsSet(true);
    this.cacheHit = cacheHit;
    setCacheHitIsSet(true);
    this.cacheMiss = cacheMiss;
    setCacheMissIsSet(true);
    this.gbytes = gbytes;
    setGbytesIsSet(true);
    this.hashBuckets = hashBuckets;
    setHashBucketsIsSet(true);
    this.hashExamined = hashExamined;
    setHashExaminedIsSet(true);
    this.hashLongest = hashLongest;
    setHashLongestIsSet(true);
    this.hashMaxNowait = hashMaxNowait;
    setHashMaxNowaitIsSet(true);
    this.hashMaxWait = hashMaxWait;
    setHashMaxWaitIsSet(true);
    this.hashMutexes = hashMutexes;
    setHashMutexesIsSet(true);
    this.hashNowait = hashNowait;
    setHashNowaitIsSet(true);
    this.hashSearches = hashSearches;
    setHashSearchesIsSet(true);
    this.hashWait = hashWait;
    setHashWaitIsSet(true);
    this.ioWait = ioWait;
    setIoWaitIsSet(true);
    this.maxNumCache = maxNumCache;
    setMaxNumCacheIsSet(true);
    this.maxOpenfd = maxOpenfd;
    setMaxOpenfdIsSet(true);
    this.maxWrite = maxWrite;
    setMaxWriteIsSet(true);
    this.maxWriteSleep = maxWriteSleep;
    setMaxWriteSleepIsSet(true);
    this.mmapSize = mmapSize;
    setMmapSizeIsSet(true);
    this.multiversionFreed = multiversionFreed;
    setMultiversionFreedIsSet(true);
    this.multiversionFrozen = multiversionFrozen;
    setMultiversionFrozenIsSet(true);
    this.multiversionReused = multiversionReused;
    setMultiversionReusedIsSet(true);
    this.multiversionThawed = multiversionThawed;
    setMultiversionThawedIsSet(true);
    this.numCache = numCache;
    setNumCacheIsSet(true);
    this.pages = pages;
    setPagesIsSet(true);
    this.pageSize = pageSize;
    setPageSizeIsSet(true);
    this.pageClean = pageClean;
    setPageCleanIsSet(true);
    this.pageCreate = pageCreate;
    setPageCreateIsSet(true);
    this.pageDirty = pageDirty;
    setPageDirtyIsSet(true);
    this.pageMapped = pageMapped;
    setPageMappedIsSet(true);
    this.pageIn = pageIn;
    setPageInIsSet(true);
    this.pageTrickle = pageTrickle;
    setPageTrickleIsSet(true);
    this.pageOut = pageOut;
    setPageOutIsSet(true);
    this.regionNowait = regionNowait;
    setRegionNowaitIsSet(true);
    this.regionWait = regionWait;
    setRegionWaitIsSet(true);
    this.regmax = regmax;
    setRegmaxIsSet(true);
    this.regSize = regSize;
    setRegSizeIsSet(true);
    this.roEvict = roEvict;
    setRoEvictIsSet(true);
    this.rwEvict = rwEvict;
    setRwEvictIsSet(true);
    this.syncInterrupted = syncInterrupted;
    setSyncInterruptedIsSet(true);
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public TCacheStat(TCacheStat other) {
    __isset_bitfield = other.__isset_bitfield;
    this.alloc = other.alloc;
    this.allocBuckets = other.allocBuckets;
    this.allocMaxBuckets = other.allocMaxBuckets;
    this.allocMaxPages = other.allocMaxPages;
    this.allocPages = other.allocPages;
    this.bytes = other.bytes;
    this.cacheHit = other.cacheHit;
    this.cacheMiss = other.cacheMiss;
    this.gbytes = other.gbytes;
    this.hashBuckets = other.hashBuckets;
    this.hashExamined = other.hashExamined;
    this.hashLongest = other.hashLongest;
    this.hashMaxNowait = other.hashMaxNowait;
    this.hashMaxWait = other.hashMaxWait;
    this.hashMutexes = other.hashMutexes;
    this.hashNowait = other.hashNowait;
    this.hashSearches = other.hashSearches;
    this.hashWait = other.hashWait;
    this.ioWait = other.ioWait;
    this.maxNumCache = other.maxNumCache;
    this.maxOpenfd = other.maxOpenfd;
    this.maxWrite = other.maxWrite;
    this.maxWriteSleep = other.maxWriteSleep;
    this.mmapSize = other.mmapSize;
    this.multiversionFreed = other.multiversionFreed;
    this.multiversionFrozen = other.multiversionFrozen;
    this.multiversionReused = other.multiversionReused;
    this.multiversionThawed = other.multiversionThawed;
    this.numCache = other.numCache;
    this.pages = other.pages;
    this.pageSize = other.pageSize;
    this.pageClean = other.pageClean;
    this.pageCreate = other.pageCreate;
    this.pageDirty = other.pageDirty;
    this.pageMapped = other.pageMapped;
    this.pageIn = other.pageIn;
    this.pageTrickle = other.pageTrickle;
    this.pageOut = other.pageOut;
    this.regionNowait = other.regionNowait;
    this.regionWait = other.regionWait;
    this.regmax = other.regmax;
    this.regSize = other.regSize;
    this.roEvict = other.roEvict;
    this.rwEvict = other.rwEvict;
    this.syncInterrupted = other.syncInterrupted;
  }

  public TCacheStat deepCopy() {
    return new TCacheStat(this);
  }

  @Override
  public void clear() {
    setAllocIsSet(false);
    this.alloc = 0;
    setAllocBucketsIsSet(false);
    this.allocBuckets = 0;
    setAllocMaxBucketsIsSet(false);
    this.allocMaxBuckets = 0;
    setAllocMaxPagesIsSet(false);
    this.allocMaxPages = 0;
    setAllocPagesIsSet(false);
    this.allocPages = 0;
    setBytesIsSet(false);
    this.bytes = 0;
    setCacheHitIsSet(false);
    this.cacheHit = 0;
    setCacheMissIsSet(false);
    this.cacheMiss = 0;
    setGbytesIsSet(false);
    this.gbytes = 0;
    setHashBucketsIsSet(false);
    this.hashBuckets = 0;
    setHashExaminedIsSet(false);
    this.hashExamined = 0;
    setHashLongestIsSet(false);
    this.hashLongest = 0;
    setHashMaxNowaitIsSet(false);
    this.hashMaxNowait = 0;
    setHashMaxWaitIsSet(false);
    this.hashMaxWait = 0;
    setHashMutexesIsSet(false);
    this.hashMutexes = 0;
    setHashNowaitIsSet(false);
    this.hashNowait = 0;
    setHashSearchesIsSet(false);
    this.hashSearches = 0;
    setHashWaitIsSet(false);
    this.hashWait = 0;
    setIoWaitIsSet(false);
    this.ioWait = 0;
    setMaxNumCacheIsSet(false);
    this.maxNumCache = 0;
    setMaxOpenfdIsSet(false);
    this.maxOpenfd = 0;
    setMaxWriteIsSet(false);
    this.maxWrite = 0;
    setMaxWriteSleepIsSet(false);
    this.maxWriteSleep = 0;
    setMmapSizeIsSet(false);
    this.mmapSize = 0;
    setMultiversionFreedIsSet(false);
    this.multiversionFreed = 0;
    setMultiversionFrozenIsSet(false);
    this.multiversionFrozen = 0;
    setMultiversionReusedIsSet(false);
    this.multiversionReused = 0;
    setMultiversionThawedIsSet(false);
    this.multiversionThawed = 0;
    setNumCacheIsSet(false);
    this.numCache = 0;
    setPagesIsSet(false);
    this.pages = 0;
    setPageSizeIsSet(false);
    this.pageSize = 0;
    setPageCleanIsSet(false);
    this.pageClean = 0;
    setPageCreateIsSet(false);
    this.pageCreate = 0;
    setPageDirtyIsSet(false);
    this.pageDirty = 0;
    setPageMappedIsSet(false);
    this.pageMapped = 0;
    setPageInIsSet(false);
    this.pageIn = 0;
    setPageTrickleIsSet(false);
    this.pageTrickle = 0;
    setPageOutIsSet(false);
    this.pageOut = 0;
    setRegionNowaitIsSet(false);
    this.regionNowait = 0;
    setRegionWaitIsSet(false);
    this.regionWait = 0;
    setRegmaxIsSet(false);
    this.regmax = 0;
    setRegSizeIsSet(false);
    this.regSize = 0;
    setRoEvictIsSet(false);
    this.roEvict = 0;
    setRwEvictIsSet(false);
    this.rwEvict = 0;
    setSyncInterruptedIsSet(false);
    this.syncInterrupted = 0;
  }

  public long getAlloc() {
    return this.alloc;
  }

  public TCacheStat setAlloc(long alloc) {
    this.alloc = alloc;
    setAllocIsSet(true);
    return this;
  }

  public void unsetAlloc() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __ALLOC_ISSET_ID);
  }

  /** Returns true if field alloc is set (has been assigned a value) and false otherwise */
  public boolean isSetAlloc() {
    return EncodingUtils.testBit(__isset_bitfield, __ALLOC_ISSET_ID);
  }

  public void setAllocIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __ALLOC_ISSET_ID, value);
  }

  public long getAllocBuckets() {
    return this.allocBuckets;
  }

  public TCacheStat setAllocBuckets(long allocBuckets) {
    this.allocBuckets = allocBuckets;
    setAllocBucketsIsSet(true);
    return this;
  }

  public void unsetAllocBuckets() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __ALLOCBUCKETS_ISSET_ID);
  }

  /** Returns true if field allocBuckets is set (has been assigned a value) and false otherwise */
  public boolean isSetAllocBuckets() {
    return EncodingUtils.testBit(__isset_bitfield, __ALLOCBUCKETS_ISSET_ID);
  }

  public void setAllocBucketsIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __ALLOCBUCKETS_ISSET_ID, value);
  }

  public long getAllocMaxBuckets() {
    return this.allocMaxBuckets;
  }

  public TCacheStat setAllocMaxBuckets(long allocMaxBuckets) {
    this.allocMaxBuckets = allocMaxBuckets;
    setAllocMaxBucketsIsSet(true);
    return this;
  }

  public void unsetAllocMaxBuckets() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __ALLOCMAXBUCKETS_ISSET_ID);
  }

  /** Returns true if field allocMaxBuckets is set (has been assigned a value) and false otherwise */
  public boolean isSetAllocMaxBuckets() {
    return EncodingUtils.testBit(__isset_bitfield, __ALLOCMAXBUCKETS_ISSET_ID);
  }

  public void setAllocMaxBucketsIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __ALLOCMAXBUCKETS_ISSET_ID, value);
  }

  public long getAllocMaxPages() {
    return this.allocMaxPages;
  }

  public TCacheStat setAllocMaxPages(long allocMaxPages) {
    this.allocMaxPages = allocMaxPages;
    setAllocMaxPagesIsSet(true);
    return this;
  }

  public void unsetAllocMaxPages() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __ALLOCMAXPAGES_ISSET_ID);
  }

  /** Returns true if field allocMaxPages is set (has been assigned a value) and false otherwise */
  public boolean isSetAllocMaxPages() {
    return EncodingUtils.testBit(__isset_bitfield, __ALLOCMAXPAGES_ISSET_ID);
  }

  public void setAllocMaxPagesIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __ALLOCMAXPAGES_ISSET_ID, value);
  }

  public long getAllocPages() {
    return this.allocPages;
  }

  public TCacheStat setAllocPages(long allocPages) {
    this.allocPages = allocPages;
    setAllocPagesIsSet(true);
    return this;
  }

  public void unsetAllocPages() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __ALLOCPAGES_ISSET_ID);
  }

  /** Returns true if field allocPages is set (has been assigned a value) and false otherwise */
  public boolean isSetAllocPages() {
    return EncodingUtils.testBit(__isset_bitfield, __ALLOCPAGES_ISSET_ID);
  }

  public void setAllocPagesIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __ALLOCPAGES_ISSET_ID, value);
  }

  public int getBytes() {
    return this.bytes;
  }

  public TCacheStat setBytes(int bytes) {
    this.bytes = bytes;
    setBytesIsSet(true);
    return this;
  }

  public void unsetBytes() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __BYTES_ISSET_ID);
  }

  /** Returns true if field bytes is set (has been assigned a value) and false otherwise */
  public boolean isSetBytes() {
    return EncodingUtils.testBit(__isset_bitfield, __BYTES_ISSET_ID);
  }

  public void setBytesIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __BYTES_ISSET_ID, value);
  }

  public long getCacheHit() {
    return this.cacheHit;
  }

  public TCacheStat setCacheHit(long cacheHit) {
    this.cacheHit = cacheHit;
    setCacheHitIsSet(true);
    return this;
  }

  public void unsetCacheHit() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __CACHEHIT_ISSET_ID);
  }

  /** Returns true if field cacheHit is set (has been assigned a value) and false otherwise */
  public boolean isSetCacheHit() {
    return EncodingUtils.testBit(__isset_bitfield, __CACHEHIT_ISSET_ID);
  }

  public void setCacheHitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __CACHEHIT_ISSET_ID, value);
  }

  public long getCacheMiss() {
    return this.cacheMiss;
  }

  public TCacheStat setCacheMiss(long cacheMiss) {
    this.cacheMiss = cacheMiss;
    setCacheMissIsSet(true);
    return this;
  }

  public void unsetCacheMiss() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __CACHEMISS_ISSET_ID);
  }

  /** Returns true if field cacheMiss is set (has been assigned a value) and false otherwise */
  public boolean isSetCacheMiss() {
    return EncodingUtils.testBit(__isset_bitfield, __CACHEMISS_ISSET_ID);
  }

  public void setCacheMissIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __CACHEMISS_ISSET_ID, value);
  }

  public int getGbytes() {
    return this.gbytes;
  }

  public TCacheStat setGbytes(int gbytes) {
    this.gbytes = gbytes;
    setGbytesIsSet(true);
    return this;
  }

  public void unsetGbytes() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __GBYTES_ISSET_ID);
  }

  /** Returns true if field gbytes is set (has been assigned a value) and false otherwise */
  public boolean isSetGbytes() {
    return EncodingUtils.testBit(__isset_bitfield, __GBYTES_ISSET_ID);
  }

  public void setGbytesIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __GBYTES_ISSET_ID, value);
  }

  public int getHashBuckets() {
    return this.hashBuckets;
  }

  public TCacheStat setHashBuckets(int hashBuckets) {
    this.hashBuckets = hashBuckets;
    setHashBucketsIsSet(true);
    return this;
  }

  public void unsetHashBuckets() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __HASHBUCKETS_ISSET_ID);
  }

  /** Returns true if field hashBuckets is set (has been assigned a value) and false otherwise */
  public boolean isSetHashBuckets() {
    return EncodingUtils.testBit(__isset_bitfield, __HASHBUCKETS_ISSET_ID);
  }

  public void setHashBucketsIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __HASHBUCKETS_ISSET_ID, value);
  }

  public long getHashExamined() {
    return this.hashExamined;
  }

  public TCacheStat setHashExamined(long hashExamined) {
    this.hashExamined = hashExamined;
    setHashExaminedIsSet(true);
    return this;
  }

  public void unsetHashExamined() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __HASHEXAMINED_ISSET_ID);
  }

  /** Returns true if field hashExamined is set (has been assigned a value) and false otherwise */
  public boolean isSetHashExamined() {
    return EncodingUtils.testBit(__isset_bitfield, __HASHEXAMINED_ISSET_ID);
  }

  public void setHashExaminedIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __HASHEXAMINED_ISSET_ID, value);
  }

  public int getHashLongest() {
    return this.hashLongest;
  }

  public TCacheStat setHashLongest(int hashLongest) {
    this.hashLongest = hashLongest;
    setHashLongestIsSet(true);
    return this;
  }

  public void unsetHashLongest() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __HASHLONGEST_ISSET_ID);
  }

  /** Returns true if field hashLongest is set (has been assigned a value) and false otherwise */
  public boolean isSetHashLongest() {
    return EncodingUtils.testBit(__isset_bitfield, __HASHLONGEST_ISSET_ID);
  }

  public void setHashLongestIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __HASHLONGEST_ISSET_ID, value);
  }

  public long getHashMaxNowait() {
    return this.hashMaxNowait;
  }

  public TCacheStat setHashMaxNowait(long hashMaxNowait) {
    this.hashMaxNowait = hashMaxNowait;
    setHashMaxNowaitIsSet(true);
    return this;
  }

  public void unsetHashMaxNowait() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __HASHMAXNOWAIT_ISSET_ID);
  }

  /** Returns true if field hashMaxNowait is set (has been assigned a value) and false otherwise */
  public boolean isSetHashMaxNowait() {
    return EncodingUtils.testBit(__isset_bitfield, __HASHMAXNOWAIT_ISSET_ID);
  }

  public void setHashMaxNowaitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __HASHMAXNOWAIT_ISSET_ID, value);
  }

  public long getHashMaxWait() {
    return this.hashMaxWait;
  }

  public TCacheStat setHashMaxWait(long hashMaxWait) {
    this.hashMaxWait = hashMaxWait;
    setHashMaxWaitIsSet(true);
    return this;
  }

  public void unsetHashMaxWait() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __HASHMAXWAIT_ISSET_ID);
  }

  /** Returns true if field hashMaxWait is set (has been assigned a value) and false otherwise */
  public boolean isSetHashMaxWait() {
    return EncodingUtils.testBit(__isset_bitfield, __HASHMAXWAIT_ISSET_ID);
  }

  public void setHashMaxWaitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __HASHMAXWAIT_ISSET_ID, value);
  }

  public int getHashMutexes() {
    return this.hashMutexes;
  }

  public TCacheStat setHashMutexes(int hashMutexes) {
    this.hashMutexes = hashMutexes;
    setHashMutexesIsSet(true);
    return this;
  }

  public void unsetHashMutexes() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __HASHMUTEXES_ISSET_ID);
  }

  /** Returns true if field hashMutexes is set (has been assigned a value) and false otherwise */
  public boolean isSetHashMutexes() {
    return EncodingUtils.testBit(__isset_bitfield, __HASHMUTEXES_ISSET_ID);
  }

  public void setHashMutexesIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __HASHMUTEXES_ISSET_ID, value);
  }

  public long getHashNowait() {
    return this.hashNowait;
  }

  public TCacheStat setHashNowait(long hashNowait) {
    this.hashNowait = hashNowait;
    setHashNowaitIsSet(true);
    return this;
  }

  public void unsetHashNowait() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __HASHNOWAIT_ISSET_ID);
  }

  /** Returns true if field hashNowait is set (has been assigned a value) and false otherwise */
  public boolean isSetHashNowait() {
    return EncodingUtils.testBit(__isset_bitfield, __HASHNOWAIT_ISSET_ID);
  }

  public void setHashNowaitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __HASHNOWAIT_ISSET_ID, value);
  }

  public int getHashSearches() {
    return this.hashSearches;
  }

  public TCacheStat setHashSearches(int hashSearches) {
    this.hashSearches = hashSearches;
    setHashSearchesIsSet(true);
    return this;
  }

  public void unsetHashSearches() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __HASHSEARCHES_ISSET_ID);
  }

  /** Returns true if field hashSearches is set (has been assigned a value) and false otherwise */
  public boolean isSetHashSearches() {
    return EncodingUtils.testBit(__isset_bitfield, __HASHSEARCHES_ISSET_ID);
  }

  public void setHashSearchesIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __HASHSEARCHES_ISSET_ID, value);
  }

  public long getHashWait() {
    return this.hashWait;
  }

  public TCacheStat setHashWait(long hashWait) {
    this.hashWait = hashWait;
    setHashWaitIsSet(true);
    return this;
  }

  public void unsetHashWait() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __HASHWAIT_ISSET_ID);
  }

  /** Returns true if field hashWait is set (has been assigned a value) and false otherwise */
  public boolean isSetHashWait() {
    return EncodingUtils.testBit(__isset_bitfield, __HASHWAIT_ISSET_ID);
  }

  public void setHashWaitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __HASHWAIT_ISSET_ID, value);
  }

  public long getIoWait() {
    return this.ioWait;
  }

  public TCacheStat setIoWait(long ioWait) {
    this.ioWait = ioWait;
    setIoWaitIsSet(true);
    return this;
  }

  public void unsetIoWait() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __IOWAIT_ISSET_ID);
  }

  /** Returns true if field ioWait is set (has been assigned a value) and false otherwise */
  public boolean isSetIoWait() {
    return EncodingUtils.testBit(__isset_bitfield, __IOWAIT_ISSET_ID);
  }

  public void setIoWaitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __IOWAIT_ISSET_ID, value);
  }

  public int getMaxNumCache() {
    return this.maxNumCache;
  }

  public TCacheStat setMaxNumCache(int maxNumCache) {
    this.maxNumCache = maxNumCache;
    setMaxNumCacheIsSet(true);
    return this;
  }

  public void unsetMaxNumCache() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MAXNUMCACHE_ISSET_ID);
  }

  /** Returns true if field maxNumCache is set (has been assigned a value) and false otherwise */
  public boolean isSetMaxNumCache() {
    return EncodingUtils.testBit(__isset_bitfield, __MAXNUMCACHE_ISSET_ID);
  }

  public void setMaxNumCacheIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MAXNUMCACHE_ISSET_ID, value);
  }

  public int getMaxOpenfd() {
    return this.maxOpenfd;
  }

  public TCacheStat setMaxOpenfd(int maxOpenfd) {
    this.maxOpenfd = maxOpenfd;
    setMaxOpenfdIsSet(true);
    return this;
  }

  public void unsetMaxOpenfd() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MAXOPENFD_ISSET_ID);
  }

  /** Returns true if field maxOpenfd is set (has been assigned a value) and false otherwise */
  public boolean isSetMaxOpenfd() {
    return EncodingUtils.testBit(__isset_bitfield, __MAXOPENFD_ISSET_ID);
  }

  public void setMaxOpenfdIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MAXOPENFD_ISSET_ID, value);
  }

  public int getMaxWrite() {
    return this.maxWrite;
  }

  public TCacheStat setMaxWrite(int maxWrite) {
    this.maxWrite = maxWrite;
    setMaxWriteIsSet(true);
    return this;
  }

  public void unsetMaxWrite() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MAXWRITE_ISSET_ID);
  }

  /** Returns true if field maxWrite is set (has been assigned a value) and false otherwise */
  public boolean isSetMaxWrite() {
    return EncodingUtils.testBit(__isset_bitfield, __MAXWRITE_ISSET_ID);
  }

  public void setMaxWriteIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MAXWRITE_ISSET_ID, value);
  }

  public int getMaxWriteSleep() {
    return this.maxWriteSleep;
  }

  public TCacheStat setMaxWriteSleep(int maxWriteSleep) {
    this.maxWriteSleep = maxWriteSleep;
    setMaxWriteSleepIsSet(true);
    return this;
  }

  public void unsetMaxWriteSleep() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MAXWRITESLEEP_ISSET_ID);
  }

  /** Returns true if field maxWriteSleep is set (has been assigned a value) and false otherwise */
  public boolean isSetMaxWriteSleep() {
    return EncodingUtils.testBit(__isset_bitfield, __MAXWRITESLEEP_ISSET_ID);
  }

  public void setMaxWriteSleepIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MAXWRITESLEEP_ISSET_ID, value);
  }

  public long getMmapSize() {
    return this.mmapSize;
  }

  public TCacheStat setMmapSize(long mmapSize) {
    this.mmapSize = mmapSize;
    setMmapSizeIsSet(true);
    return this;
  }

  public void unsetMmapSize() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MMAPSIZE_ISSET_ID);
  }

  /** Returns true if field mmapSize is set (has been assigned a value) and false otherwise */
  public boolean isSetMmapSize() {
    return EncodingUtils.testBit(__isset_bitfield, __MMAPSIZE_ISSET_ID);
  }

  public void setMmapSizeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MMAPSIZE_ISSET_ID, value);
  }

  public long getMultiversionFreed() {
    return this.multiversionFreed;
  }

  public TCacheStat setMultiversionFreed(long multiversionFreed) {
    this.multiversionFreed = multiversionFreed;
    setMultiversionFreedIsSet(true);
    return this;
  }

  public void unsetMultiversionFreed() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MULTIVERSIONFREED_ISSET_ID);
  }

  /** Returns true if field multiversionFreed is set (has been assigned a value) and false otherwise */
  public boolean isSetMultiversionFreed() {
    return EncodingUtils.testBit(__isset_bitfield, __MULTIVERSIONFREED_ISSET_ID);
  }

  public void setMultiversionFreedIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MULTIVERSIONFREED_ISSET_ID, value);
  }

  public long getMultiversionFrozen() {
    return this.multiversionFrozen;
  }

  public TCacheStat setMultiversionFrozen(long multiversionFrozen) {
    this.multiversionFrozen = multiversionFrozen;
    setMultiversionFrozenIsSet(true);
    return this;
  }

  public void unsetMultiversionFrozen() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MULTIVERSIONFROZEN_ISSET_ID);
  }

  /** Returns true if field multiversionFrozen is set (has been assigned a value) and false otherwise */
  public boolean isSetMultiversionFrozen() {
    return EncodingUtils.testBit(__isset_bitfield, __MULTIVERSIONFROZEN_ISSET_ID);
  }

  public void setMultiversionFrozenIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MULTIVERSIONFROZEN_ISSET_ID, value);
  }

  public long getMultiversionReused() {
    return this.multiversionReused;
  }

  public TCacheStat setMultiversionReused(long multiversionReused) {
    this.multiversionReused = multiversionReused;
    setMultiversionReusedIsSet(true);
    return this;
  }

  public void unsetMultiversionReused() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MULTIVERSIONREUSED_ISSET_ID);
  }

  /** Returns true if field multiversionReused is set (has been assigned a value) and false otherwise */
  public boolean isSetMultiversionReused() {
    return EncodingUtils.testBit(__isset_bitfield, __MULTIVERSIONREUSED_ISSET_ID);
  }

  public void setMultiversionReusedIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MULTIVERSIONREUSED_ISSET_ID, value);
  }

  public long getMultiversionThawed() {
    return this.multiversionThawed;
  }

  public TCacheStat setMultiversionThawed(long multiversionThawed) {
    this.multiversionThawed = multiversionThawed;
    setMultiversionThawedIsSet(true);
    return this;
  }

  public void unsetMultiversionThawed() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MULTIVERSIONTHAWED_ISSET_ID);
  }

  /** Returns true if field multiversionThawed is set (has been assigned a value) and false otherwise */
  public boolean isSetMultiversionThawed() {
    return EncodingUtils.testBit(__isset_bitfield, __MULTIVERSIONTHAWED_ISSET_ID);
  }

  public void setMultiversionThawedIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MULTIVERSIONTHAWED_ISSET_ID, value);
  }

  public int getNumCache() {
    return this.numCache;
  }

  public TCacheStat setNumCache(int numCache) {
    this.numCache = numCache;
    setNumCacheIsSet(true);
    return this;
  }

  public void unsetNumCache() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __NUMCACHE_ISSET_ID);
  }

  /** Returns true if field numCache is set (has been assigned a value) and false otherwise */
  public boolean isSetNumCache() {
    return EncodingUtils.testBit(__isset_bitfield, __NUMCACHE_ISSET_ID);
  }

  public void setNumCacheIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __NUMCACHE_ISSET_ID, value);
  }

  public int getPages() {
    return this.pages;
  }

  public TCacheStat setPages(int pages) {
    this.pages = pages;
    setPagesIsSet(true);
    return this;
  }

  public void unsetPages() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __PAGES_ISSET_ID);
  }

  /** Returns true if field pages is set (has been assigned a value) and false otherwise */
  public boolean isSetPages() {
    return EncodingUtils.testBit(__isset_bitfield, __PAGES_ISSET_ID);
  }

  public void setPagesIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __PAGES_ISSET_ID, value);
  }

  public int getPageSize() {
    return this.pageSize;
  }

  public TCacheStat setPageSize(int pageSize) {
    this.pageSize = pageSize;
    setPageSizeIsSet(true);
    return this;
  }

  public void unsetPageSize() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __PAGESIZE_ISSET_ID);
  }

  /** Returns true if field pageSize is set (has been assigned a value) and false otherwise */
  public boolean isSetPageSize() {
    return EncodingUtils.testBit(__isset_bitfield, __PAGESIZE_ISSET_ID);
  }

  public void setPageSizeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __PAGESIZE_ISSET_ID, value);
  }

  public int getPageClean() {
    return this.pageClean;
  }

  public TCacheStat setPageClean(int pageClean) {
    this.pageClean = pageClean;
    setPageCleanIsSet(true);
    return this;
  }

  public void unsetPageClean() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __PAGECLEAN_ISSET_ID);
  }

  /** Returns true if field pageClean is set (has been assigned a value) and false otherwise */
  public boolean isSetPageClean() {
    return EncodingUtils.testBit(__isset_bitfield, __PAGECLEAN_ISSET_ID);
  }

  public void setPageCleanIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __PAGECLEAN_ISSET_ID, value);
  }

  public long getPageCreate() {
    return this.pageCreate;
  }

  public TCacheStat setPageCreate(long pageCreate) {
    this.pageCreate = pageCreate;
    setPageCreateIsSet(true);
    return this;
  }

  public void unsetPageCreate() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __PAGECREATE_ISSET_ID);
  }

  /** Returns true if field pageCreate is set (has been assigned a value) and false otherwise */
  public boolean isSetPageCreate() {
    return EncodingUtils.testBit(__isset_bitfield, __PAGECREATE_ISSET_ID);
  }

  public void setPageCreateIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __PAGECREATE_ISSET_ID, value);
  }

  public int getPageDirty() {
    return this.pageDirty;
  }

  public TCacheStat setPageDirty(int pageDirty) {
    this.pageDirty = pageDirty;
    setPageDirtyIsSet(true);
    return this;
  }

  public void unsetPageDirty() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __PAGEDIRTY_ISSET_ID);
  }

  /** Returns true if field pageDirty is set (has been assigned a value) and false otherwise */
  public boolean isSetPageDirty() {
    return EncodingUtils.testBit(__isset_bitfield, __PAGEDIRTY_ISSET_ID);
  }

  public void setPageDirtyIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __PAGEDIRTY_ISSET_ID, value);
  }

  public int getPageMapped() {
    return this.pageMapped;
  }

  public TCacheStat setPageMapped(int pageMapped) {
    this.pageMapped = pageMapped;
    setPageMappedIsSet(true);
    return this;
  }

  public void unsetPageMapped() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __PAGEMAPPED_ISSET_ID);
  }

  /** Returns true if field pageMapped is set (has been assigned a value) and false otherwise */
  public boolean isSetPageMapped() {
    return EncodingUtils.testBit(__isset_bitfield, __PAGEMAPPED_ISSET_ID);
  }

  public void setPageMappedIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __PAGEMAPPED_ISSET_ID, value);
  }

  public long getPageIn() {
    return this.pageIn;
  }

  public TCacheStat setPageIn(long pageIn) {
    this.pageIn = pageIn;
    setPageInIsSet(true);
    return this;
  }

  public void unsetPageIn() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __PAGEIN_ISSET_ID);
  }

  /** Returns true if field pageIn is set (has been assigned a value) and false otherwise */
  public boolean isSetPageIn() {
    return EncodingUtils.testBit(__isset_bitfield, __PAGEIN_ISSET_ID);
  }

  public void setPageInIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __PAGEIN_ISSET_ID, value);
  }

  public long getPageTrickle() {
    return this.pageTrickle;
  }

  public TCacheStat setPageTrickle(long pageTrickle) {
    this.pageTrickle = pageTrickle;
    setPageTrickleIsSet(true);
    return this;
  }

  public void unsetPageTrickle() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __PAGETRICKLE_ISSET_ID);
  }

  /** Returns true if field pageTrickle is set (has been assigned a value) and false otherwise */
  public boolean isSetPageTrickle() {
    return EncodingUtils.testBit(__isset_bitfield, __PAGETRICKLE_ISSET_ID);
  }

  public void setPageTrickleIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __PAGETRICKLE_ISSET_ID, value);
  }

  public long getPageOut() {
    return this.pageOut;
  }

  public TCacheStat setPageOut(long pageOut) {
    this.pageOut = pageOut;
    setPageOutIsSet(true);
    return this;
  }

  public void unsetPageOut() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __PAGEOUT_ISSET_ID);
  }

  /** Returns true if field pageOut is set (has been assigned a value) and false otherwise */
  public boolean isSetPageOut() {
    return EncodingUtils.testBit(__isset_bitfield, __PAGEOUT_ISSET_ID);
  }

  public void setPageOutIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __PAGEOUT_ISSET_ID, value);
  }

  public long getRegionNowait() {
    return this.regionNowait;
  }

  public TCacheStat setRegionNowait(long regionNowait) {
    this.regionNowait = regionNowait;
    setRegionNowaitIsSet(true);
    return this;
  }

  public void unsetRegionNowait() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __REGIONNOWAIT_ISSET_ID);
  }

  /** Returns true if field regionNowait is set (has been assigned a value) and false otherwise */
  public boolean isSetRegionNowait() {
    return EncodingUtils.testBit(__isset_bitfield, __REGIONNOWAIT_ISSET_ID);
  }

  public void setRegionNowaitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __REGIONNOWAIT_ISSET_ID, value);
  }

  public long getRegionWait() {
    return this.regionWait;
  }

  public TCacheStat setRegionWait(long regionWait) {
    this.regionWait = regionWait;
    setRegionWaitIsSet(true);
    return this;
  }

  public void unsetRegionWait() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __REGIONWAIT_ISSET_ID);
  }

  /** Returns true if field regionWait is set (has been assigned a value) and false otherwise */
  public boolean isSetRegionWait() {
    return EncodingUtils.testBit(__isset_bitfield, __REGIONWAIT_ISSET_ID);
  }

  public void setRegionWaitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __REGIONWAIT_ISSET_ID, value);
  }

  public long getRegmax() {
    return this.regmax;
  }

  public TCacheStat setRegmax(long regmax) {
    this.regmax = regmax;
    setRegmaxIsSet(true);
    return this;
  }

  public void unsetRegmax() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __REGMAX_ISSET_ID);
  }

  /** Returns true if field regmax is set (has been assigned a value) and false otherwise */
  public boolean isSetRegmax() {
    return EncodingUtils.testBit(__isset_bitfield, __REGMAX_ISSET_ID);
  }

  public void setRegmaxIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __REGMAX_ISSET_ID, value);
  }

  public long getRegSize() {
    return this.regSize;
  }

  public TCacheStat setRegSize(long regSize) {
    this.regSize = regSize;
    setRegSizeIsSet(true);
    return this;
  }

  public void unsetRegSize() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __REGSIZE_ISSET_ID);
  }

  /** Returns true if field regSize is set (has been assigned a value) and false otherwise */
  public boolean isSetRegSize() {
    return EncodingUtils.testBit(__isset_bitfield, __REGSIZE_ISSET_ID);
  }

  public void setRegSizeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __REGSIZE_ISSET_ID, value);
  }

  public long getRoEvict() {
    return this.roEvict;
  }

  public TCacheStat setRoEvict(long roEvict) {
    this.roEvict = roEvict;
    setRoEvictIsSet(true);
    return this;
  }

  public void unsetRoEvict() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __ROEVICT_ISSET_ID);
  }

  /** Returns true if field roEvict is set (has been assigned a value) and false otherwise */
  public boolean isSetRoEvict() {
    return EncodingUtils.testBit(__isset_bitfield, __ROEVICT_ISSET_ID);
  }

  public void setRoEvictIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __ROEVICT_ISSET_ID, value);
  }

  public long getRwEvict() {
    return this.rwEvict;
  }

  public TCacheStat setRwEvict(long rwEvict) {
    this.rwEvict = rwEvict;
    setRwEvictIsSet(true);
    return this;
  }

  public void unsetRwEvict() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __RWEVICT_ISSET_ID);
  }

  /** Returns true if field rwEvict is set (has been assigned a value) and false otherwise */
  public boolean isSetRwEvict() {
    return EncodingUtils.testBit(__isset_bitfield, __RWEVICT_ISSET_ID);
  }

  public void setRwEvictIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __RWEVICT_ISSET_ID, value);
  }

  public long getSyncInterrupted() {
    return this.syncInterrupted;
  }

  public TCacheStat setSyncInterrupted(long syncInterrupted) {
    this.syncInterrupted = syncInterrupted;
    setSyncInterruptedIsSet(true);
    return this;
  }

  public void unsetSyncInterrupted() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SYNCINTERRUPTED_ISSET_ID);
  }

  /** Returns true if field syncInterrupted is set (has been assigned a value) and false otherwise */
  public boolean isSetSyncInterrupted() {
    return EncodingUtils.testBit(__isset_bitfield, __SYNCINTERRUPTED_ISSET_ID);
  }

  public void setSyncInterruptedIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SYNCINTERRUPTED_ISSET_ID, value);
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case ALLOC:
      if (value == null) {
        unsetAlloc();
      } else {
        setAlloc((Long)value);
      }
      break;

    case ALLOC_BUCKETS:
      if (value == null) {
        unsetAllocBuckets();
      } else {
        setAllocBuckets((Long)value);
      }
      break;

    case ALLOC_MAX_BUCKETS:
      if (value == null) {
        unsetAllocMaxBuckets();
      } else {
        setAllocMaxBuckets((Long)value);
      }
      break;

    case ALLOC_MAX_PAGES:
      if (value == null) {
        unsetAllocMaxPages();
      } else {
        setAllocMaxPages((Long)value);
      }
      break;

    case ALLOC_PAGES:
      if (value == null) {
        unsetAllocPages();
      } else {
        setAllocPages((Long)value);
      }
      break;

    case BYTES:
      if (value == null) {
        unsetBytes();
      } else {
        setBytes((Integer)value);
      }
      break;

    case CACHE_HIT:
      if (value == null) {
        unsetCacheHit();
      } else {
        setCacheHit((Long)value);
      }
      break;

    case CACHE_MISS:
      if (value == null) {
        unsetCacheMiss();
      } else {
        setCacheMiss((Long)value);
      }
      break;

    case GBYTES:
      if (value == null) {
        unsetGbytes();
      } else {
        setGbytes((Integer)value);
      }
      break;

    case HASH_BUCKETS:
      if (value == null) {
        unsetHashBuckets();
      } else {
        setHashBuckets((Integer)value);
      }
      break;

    case HASH_EXAMINED:
      if (value == null) {
        unsetHashExamined();
      } else {
        setHashExamined((Long)value);
      }
      break;

    case HASH_LONGEST:
      if (value == null) {
        unsetHashLongest();
      } else {
        setHashLongest((Integer)value);
      }
      break;

    case HASH_MAX_NOWAIT:
      if (value == null) {
        unsetHashMaxNowait();
      } else {
        setHashMaxNowait((Long)value);
      }
      break;

    case HASH_MAX_WAIT:
      if (value == null) {
        unsetHashMaxWait();
      } else {
        setHashMaxWait((Long)value);
      }
      break;

    case HASH_MUTEXES:
      if (value == null) {
        unsetHashMutexes();
      } else {
        setHashMutexes((Integer)value);
      }
      break;

    case HASH_NOWAIT:
      if (value == null) {
        unsetHashNowait();
      } else {
        setHashNowait((Long)value);
      }
      break;

    case HASH_SEARCHES:
      if (value == null) {
        unsetHashSearches();
      } else {
        setHashSearches((Integer)value);
      }
      break;

    case HASH_WAIT:
      if (value == null) {
        unsetHashWait();
      } else {
        setHashWait((Long)value);
      }
      break;

    case IO_WAIT:
      if (value == null) {
        unsetIoWait();
      } else {
        setIoWait((Long)value);
      }
      break;

    case MAX_NUM_CACHE:
      if (value == null) {
        unsetMaxNumCache();
      } else {
        setMaxNumCache((Integer)value);
      }
      break;

    case MAX_OPENFD:
      if (value == null) {
        unsetMaxOpenfd();
      } else {
        setMaxOpenfd((Integer)value);
      }
      break;

    case MAX_WRITE:
      if (value == null) {
        unsetMaxWrite();
      } else {
        setMaxWrite((Integer)value);
      }
      break;

    case MAX_WRITE_SLEEP:
      if (value == null) {
        unsetMaxWriteSleep();
      } else {
        setMaxWriteSleep((Integer)value);
      }
      break;

    case MMAP_SIZE:
      if (value == null) {
        unsetMmapSize();
      } else {
        setMmapSize((Long)value);
      }
      break;

    case MULTIVERSION_FREED:
      if (value == null) {
        unsetMultiversionFreed();
      } else {
        setMultiversionFreed((Long)value);
      }
      break;

    case MULTIVERSION_FROZEN:
      if (value == null) {
        unsetMultiversionFrozen();
      } else {
        setMultiversionFrozen((Long)value);
      }
      break;

    case MULTIVERSION_REUSED:
      if (value == null) {
        unsetMultiversionReused();
      } else {
        setMultiversionReused((Long)value);
      }
      break;

    case MULTIVERSION_THAWED:
      if (value == null) {
        unsetMultiversionThawed();
      } else {
        setMultiversionThawed((Long)value);
      }
      break;

    case NUM_CACHE:
      if (value == null) {
        unsetNumCache();
      } else {
        setNumCache((Integer)value);
      }
      break;

    case PAGES:
      if (value == null) {
        unsetPages();
      } else {
        setPages((Integer)value);
      }
      break;

    case PAGE_SIZE:
      if (value == null) {
        unsetPageSize();
      } else {
        setPageSize((Integer)value);
      }
      break;

    case PAGE_CLEAN:
      if (value == null) {
        unsetPageClean();
      } else {
        setPageClean((Integer)value);
      }
      break;

    case PAGE_CREATE:
      if (value == null) {
        unsetPageCreate();
      } else {
        setPageCreate((Long)value);
      }
      break;

    case PAGE_DIRTY:
      if (value == null) {
        unsetPageDirty();
      } else {
        setPageDirty((Integer)value);
      }
      break;

    case PAGE_MAPPED:
      if (value == null) {
        unsetPageMapped();
      } else {
        setPageMapped((Integer)value);
      }
      break;

    case PAGE_IN:
      if (value == null) {
        unsetPageIn();
      } else {
        setPageIn((Long)value);
      }
      break;

    case PAGE_TRICKLE:
      if (value == null) {
        unsetPageTrickle();
      } else {
        setPageTrickle((Long)value);
      }
      break;

    case PAGE_OUT:
      if (value == null) {
        unsetPageOut();
      } else {
        setPageOut((Long)value);
      }
      break;

    case REGION_NOWAIT:
      if (value == null) {
        unsetRegionNowait();
      } else {
        setRegionNowait((Long)value);
      }
      break;

    case REGION_WAIT:
      if (value == null) {
        unsetRegionWait();
      } else {
        setRegionWait((Long)value);
      }
      break;

    case REGMAX:
      if (value == null) {
        unsetRegmax();
      } else {
        setRegmax((Long)value);
      }
      break;

    case REG_SIZE:
      if (value == null) {
        unsetRegSize();
      } else {
        setRegSize((Long)value);
      }
      break;

    case RO_EVICT:
      if (value == null) {
        unsetRoEvict();
      } else {
        setRoEvict((Long)value);
      }
      break;

    case RW_EVICT:
      if (value == null) {
        unsetRwEvict();
      } else {
        setRwEvict((Long)value);
      }
      break;

    case SYNC_INTERRUPTED:
      if (value == null) {
        unsetSyncInterrupted();
      } else {
        setSyncInterrupted((Long)value);
      }
      break;

    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case ALLOC:
      return Long.valueOf(getAlloc());

    case ALLOC_BUCKETS:
      return Long.valueOf(getAllocBuckets());

    case ALLOC_MAX_BUCKETS:
      return Long.valueOf(getAllocMaxBuckets());

    case ALLOC_MAX_PAGES:
      return Long.valueOf(getAllocMaxPages());

    case ALLOC_PAGES:
      return Long.valueOf(getAllocPages());

    case BYTES:
      return Integer.valueOf(getBytes());

    case CACHE_HIT:
      return Long.valueOf(getCacheHit());

    case CACHE_MISS:
      return Long.valueOf(getCacheMiss());

    case GBYTES:
      return Integer.valueOf(getGbytes());

    case HASH_BUCKETS:
      return Integer.valueOf(getHashBuckets());

    case HASH_EXAMINED:
      return Long.valueOf(getHashExamined());

    case HASH_LONGEST:
      return Integer.valueOf(getHashLongest());

    case HASH_MAX_NOWAIT:
      return Long.valueOf(getHashMaxNowait());

    case HASH_MAX_WAIT:
      return Long.valueOf(getHashMaxWait());

    case HASH_MUTEXES:
      return Integer.valueOf(getHashMutexes());

    case HASH_NOWAIT:
      return Long.valueOf(getHashNowait());

    case HASH_SEARCHES:
      return Integer.valueOf(getHashSearches());

    case HASH_WAIT:
      return Long.valueOf(getHashWait());

    case IO_WAIT:
      return Long.valueOf(getIoWait());

    case MAX_NUM_CACHE:
      return Integer.valueOf(getMaxNumCache());

    case MAX_OPENFD:
      return Integer.valueOf(getMaxOpenfd());

    case MAX_WRITE:
      return Integer.valueOf(getMaxWrite());

    case MAX_WRITE_SLEEP:
      return Integer.valueOf(getMaxWriteSleep());

    case MMAP_SIZE:
      return Long.valueOf(getMmapSize());

    case MULTIVERSION_FREED:
      return Long.valueOf(getMultiversionFreed());

    case MULTIVERSION_FROZEN:
      return Long.valueOf(getMultiversionFrozen());

    case MULTIVERSION_REUSED:
      return Long.valueOf(getMultiversionReused());

    case MULTIVERSION_THAWED:
      return Long.valueOf(getMultiversionThawed());

    case NUM_CACHE:
      return Integer.valueOf(getNumCache());

    case PAGES:
      return Integer.valueOf(getPages());

    case PAGE_SIZE:
      return Integer.valueOf(getPageSize());

    case PAGE_CLEAN:
      return Integer.valueOf(getPageClean());

    case PAGE_CREATE:
      return Long.valueOf(getPageCreate());

    case PAGE_DIRTY:
      return Integer.valueOf(getPageDirty());

    case PAGE_MAPPED:
      return Integer.valueOf(getPageMapped());

    case PAGE_IN:
      return Long.valueOf(getPageIn());

    case PAGE_TRICKLE:
      return Long.valueOf(getPageTrickle());

    case PAGE_OUT:
      return Long.valueOf(getPageOut());

    case REGION_NOWAIT:
      return Long.valueOf(getRegionNowait());

    case REGION_WAIT:
      return Long.valueOf(getRegionWait());

    case REGMAX:
      return Long.valueOf(getRegmax());

    case REG_SIZE:
      return Long.valueOf(getRegSize());

    case RO_EVICT:
      return Long.valueOf(getRoEvict());

    case RW_EVICT:
      return Long.valueOf(getRwEvict());

    case SYNC_INTERRUPTED:
      return Long.valueOf(getSyncInterrupted());

    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case ALLOC:
      return isSetAlloc();
    case ALLOC_BUCKETS:
      return isSetAllocBuckets();
    case ALLOC_MAX_BUCKETS:
      return isSetAllocMaxBuckets();
    case ALLOC_MAX_PAGES:
      return isSetAllocMaxPages();
    case ALLOC_PAGES:
      return isSetAllocPages();
    case BYTES:
      return isSetBytes();
    case CACHE_HIT:
      return isSetCacheHit();
    case CACHE_MISS:
      return isSetCacheMiss();
    case GBYTES:
      return isSetGbytes();
    case HASH_BUCKETS:
      return isSetHashBuckets();
    case HASH_EXAMINED:
      return isSetHashExamined();
    case HASH_LONGEST:
      return isSetHashLongest();
    case HASH_MAX_NOWAIT:
      return isSetHashMaxNowait();
    case HASH_MAX_WAIT:
      return isSetHashMaxWait();
    case HASH_MUTEXES:
      return isSetHashMutexes();
    case HASH_NOWAIT:
      return isSetHashNowait();
    case HASH_SEARCHES:
      return isSetHashSearches();
    case HASH_WAIT:
      return isSetHashWait();
    case IO_WAIT:
      return isSetIoWait();
    case MAX_NUM_CACHE:
      return isSetMaxNumCache();
    case MAX_OPENFD:
      return isSetMaxOpenfd();
    case MAX_WRITE:
      return isSetMaxWrite();
    case MAX_WRITE_SLEEP:
      return isSetMaxWriteSleep();
    case MMAP_SIZE:
      return isSetMmapSize();
    case MULTIVERSION_FREED:
      return isSetMultiversionFreed();
    case MULTIVERSION_FROZEN:
      return isSetMultiversionFrozen();
    case MULTIVERSION_REUSED:
      return isSetMultiversionReused();
    case MULTIVERSION_THAWED:
      return isSetMultiversionThawed();
    case NUM_CACHE:
      return isSetNumCache();
    case PAGES:
      return isSetPages();
    case PAGE_SIZE:
      return isSetPageSize();
    case PAGE_CLEAN:
      return isSetPageClean();
    case PAGE_CREATE:
      return isSetPageCreate();
    case PAGE_DIRTY:
      return isSetPageDirty();
    case PAGE_MAPPED:
      return isSetPageMapped();
    case PAGE_IN:
      return isSetPageIn();
    case PAGE_TRICKLE:
      return isSetPageTrickle();
    case PAGE_OUT:
      return isSetPageOut();
    case REGION_NOWAIT:
      return isSetRegionNowait();
    case REGION_WAIT:
      return isSetRegionWait();
    case REGMAX:
      return isSetRegmax();
    case REG_SIZE:
      return isSetRegSize();
    case RO_EVICT:
      return isSetRoEvict();
    case RW_EVICT:
      return isSetRwEvict();
    case SYNC_INTERRUPTED:
      return isSetSyncInterrupted();
    }
    throw new IllegalStateException();
  }

  @Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof TCacheStat)
      return this.equals((TCacheStat)that);
    return false;
  }

  public boolean equals(TCacheStat that) {
    if (that == null)
      return false;

    boolean this_present_alloc = true;
    boolean that_present_alloc = true;
    if (this_present_alloc || that_present_alloc) {
      if (!(this_present_alloc && that_present_alloc))
        return false;
      if (this.alloc != that.alloc)
        return false;
    }

    boolean this_present_allocBuckets = true;
    boolean that_present_allocBuckets = true;
    if (this_present_allocBuckets || that_present_allocBuckets) {
      if (!(this_present_allocBuckets && that_present_allocBuckets))
        return false;
      if (this.allocBuckets != that.allocBuckets)
        return false;
    }

    boolean this_present_allocMaxBuckets = true;
    boolean that_present_allocMaxBuckets = true;
    if (this_present_allocMaxBuckets || that_present_allocMaxBuckets) {
      if (!(this_present_allocMaxBuckets && that_present_allocMaxBuckets))
        return false;
      if (this.allocMaxBuckets != that.allocMaxBuckets)
        return false;
    }

    boolean this_present_allocMaxPages = true;
    boolean that_present_allocMaxPages = true;
    if (this_present_allocMaxPages || that_present_allocMaxPages) {
      if (!(this_present_allocMaxPages && that_present_allocMaxPages))
        return false;
      if (this.allocMaxPages != that.allocMaxPages)
        return false;
    }

    boolean this_present_allocPages = true;
    boolean that_present_allocPages = true;
    if (this_present_allocPages || that_present_allocPages) {
      if (!(this_present_allocPages && that_present_allocPages))
        return false;
      if (this.allocPages != that.allocPages)
        return false;
    }

    boolean this_present_bytes = true;
    boolean that_present_bytes = true;
    if (this_present_bytes || that_present_bytes) {
      if (!(this_present_bytes && that_present_bytes))
        return false;
      if (this.bytes != that.bytes)
        return false;
    }

    boolean this_present_cacheHit = true;
    boolean that_present_cacheHit = true;
    if (this_present_cacheHit || that_present_cacheHit) {
      if (!(this_present_cacheHit && that_present_cacheHit))
        return false;
      if (this.cacheHit != that.cacheHit)
        return false;
    }

    boolean this_present_cacheMiss = true;
    boolean that_present_cacheMiss = true;
    if (this_present_cacheMiss || that_present_cacheMiss) {
      if (!(this_present_cacheMiss && that_present_cacheMiss))
        return false;
      if (this.cacheMiss != that.cacheMiss)
        return false;
    }

    boolean this_present_gbytes = true;
    boolean that_present_gbytes = true;
    if (this_present_gbytes || that_present_gbytes) {
      if (!(this_present_gbytes && that_present_gbytes))
        return false;
      if (this.gbytes != that.gbytes)
        return false;
    }

    boolean this_present_hashBuckets = true;
    boolean that_present_hashBuckets = true;
    if (this_present_hashBuckets || that_present_hashBuckets) {
      if (!(this_present_hashBuckets && that_present_hashBuckets))
        return false;
      if (this.hashBuckets != that.hashBuckets)
        return false;
    }

    boolean this_present_hashExamined = true;
    boolean that_present_hashExamined = true;
    if (this_present_hashExamined || that_present_hashExamined) {
      if (!(this_present_hashExamined && that_present_hashExamined))
        return false;
      if (this.hashExamined != that.hashExamined)
        return false;
    }

    boolean this_present_hashLongest = true;
    boolean that_present_hashLongest = true;
    if (this_present_hashLongest || that_present_hashLongest) {
      if (!(this_present_hashLongest && that_present_hashLongest))
        return false;
      if (this.hashLongest != that.hashLongest)
        return false;
    }

    boolean this_present_hashMaxNowait = true;
    boolean that_present_hashMaxNowait = true;
    if (this_present_hashMaxNowait || that_present_hashMaxNowait) {
      if (!(this_present_hashMaxNowait && that_present_hashMaxNowait))
        return false;
      if (this.hashMaxNowait != that.hashMaxNowait)
        return false;
    }

    boolean this_present_hashMaxWait = true;
    boolean that_present_hashMaxWait = true;
    if (this_present_hashMaxWait || that_present_hashMaxWait) {
      if (!(this_present_hashMaxWait && that_present_hashMaxWait))
        return false;
      if (this.hashMaxWait != that.hashMaxWait)
        return false;
    }

    boolean this_present_hashMutexes = true;
    boolean that_present_hashMutexes = true;
    if (this_present_hashMutexes || that_present_hashMutexes) {
      if (!(this_present_hashMutexes && that_present_hashMutexes))
        return false;
      if (this.hashMutexes != that.hashMutexes)
        return false;
    }

    boolean this_present_hashNowait = true;
    boolean that_present_hashNowait = true;
    if (this_present_hashNowait || that_present_hashNowait) {
      if (!(this_present_hashNowait && that_present_hashNowait))
        return false;
      if (this.hashNowait != that.hashNowait)
        return false;
    }

    boolean this_present_hashSearches = true;
    boolean that_present_hashSearches = true;
    if (this_present_hashSearches || that_present_hashSearches) {
      if (!(this_present_hashSearches && that_present_hashSearches))
        return false;
      if (this.hashSearches != that.hashSearches)
        return false;
    }

    boolean this_present_hashWait = true;
    boolean that_present_hashWait = true;
    if (this_present_hashWait || that_present_hashWait) {
      if (!(this_present_hashWait && that_present_hashWait))
        return false;
      if (this.hashWait != that.hashWait)
        return false;
    }

    boolean this_present_ioWait = true;
    boolean that_present_ioWait = true;
    if (this_present_ioWait || that_present_ioWait) {
      if (!(this_present_ioWait && that_present_ioWait))
        return false;
      if (this.ioWait != that.ioWait)
        return false;
    }

    boolean this_present_maxNumCache = true;
    boolean that_present_maxNumCache = true;
    if (this_present_maxNumCache || that_present_maxNumCache) {
      if (!(this_present_maxNumCache && that_present_maxNumCache))
        return false;
      if (this.maxNumCache != that.maxNumCache)
        return false;
    }

    boolean this_present_maxOpenfd = true;
    boolean that_present_maxOpenfd = true;
    if (this_present_maxOpenfd || that_present_maxOpenfd) {
      if (!(this_present_maxOpenfd && that_present_maxOpenfd))
        return false;
      if (this.maxOpenfd != that.maxOpenfd)
        return false;
    }

    boolean this_present_maxWrite = true;
    boolean that_present_maxWrite = true;
    if (this_present_maxWrite || that_present_maxWrite) {
      if (!(this_present_maxWrite && that_present_maxWrite))
        return false;
      if (this.maxWrite != that.maxWrite)
        return false;
    }

    boolean this_present_maxWriteSleep = true;
    boolean that_present_maxWriteSleep = true;
    if (this_present_maxWriteSleep || that_present_maxWriteSleep) {
      if (!(this_present_maxWriteSleep && that_present_maxWriteSleep))
        return false;
      if (this.maxWriteSleep != that.maxWriteSleep)
        return false;
    }

    boolean this_present_mmapSize = true;
    boolean that_present_mmapSize = true;
    if (this_present_mmapSize || that_present_mmapSize) {
      if (!(this_present_mmapSize && that_present_mmapSize))
        return false;
      if (this.mmapSize != that.mmapSize)
        return false;
    }

    boolean this_present_multiversionFreed = true;
    boolean that_present_multiversionFreed = true;
    if (this_present_multiversionFreed || that_present_multiversionFreed) {
      if (!(this_present_multiversionFreed && that_present_multiversionFreed))
        return false;
      if (this.multiversionFreed != that.multiversionFreed)
        return false;
    }

    boolean this_present_multiversionFrozen = true;
    boolean that_present_multiversionFrozen = true;
    if (this_present_multiversionFrozen || that_present_multiversionFrozen) {
      if (!(this_present_multiversionFrozen && that_present_multiversionFrozen))
        return false;
      if (this.multiversionFrozen != that.multiversionFrozen)
        return false;
    }

    boolean this_present_multiversionReused = true;
    boolean that_present_multiversionReused = true;
    if (this_present_multiversionReused || that_present_multiversionReused) {
      if (!(this_present_multiversionReused && that_present_multiversionReused))
        return false;
      if (this.multiversionReused != that.multiversionReused)
        return false;
    }

    boolean this_present_multiversionThawed = true;
    boolean that_present_multiversionThawed = true;
    if (this_present_multiversionThawed || that_present_multiversionThawed) {
      if (!(this_present_multiversionThawed && that_present_multiversionThawed))
        return false;
      if (this.multiversionThawed != that.multiversionThawed)
        return false;
    }

    boolean this_present_numCache = true;
    boolean that_present_numCache = true;
    if (this_present_numCache || that_present_numCache) {
      if (!(this_present_numCache && that_present_numCache))
        return false;
      if (this.numCache != that.numCache)
        return false;
    }

    boolean this_present_pages = true;
    boolean that_present_pages = true;
    if (this_present_pages || that_present_pages) {
      if (!(this_present_pages && that_present_pages))
        return false;
      if (this.pages != that.pages)
        return false;
    }

    boolean this_present_pageSize = true;
    boolean that_present_pageSize = true;
    if (this_present_pageSize || that_present_pageSize) {
      if (!(this_present_pageSize && that_present_pageSize))
        return false;
      if (this.pageSize != that.pageSize)
        return false;
    }

    boolean this_present_pageClean = true;
    boolean that_present_pageClean = true;
    if (this_present_pageClean || that_present_pageClean) {
      if (!(this_present_pageClean && that_present_pageClean))
        return false;
      if (this.pageClean != that.pageClean)
        return false;
    }

    boolean this_present_pageCreate = true;
    boolean that_present_pageCreate = true;
    if (this_present_pageCreate || that_present_pageCreate) {
      if (!(this_present_pageCreate && that_present_pageCreate))
        return false;
      if (this.pageCreate != that.pageCreate)
        return false;
    }

    boolean this_present_pageDirty = true;
    boolean that_present_pageDirty = true;
    if (this_present_pageDirty || that_present_pageDirty) {
      if (!(this_present_pageDirty && that_present_pageDirty))
        return false;
      if (this.pageDirty != that.pageDirty)
        return false;
    }

    boolean this_present_pageMapped = true;
    boolean that_present_pageMapped = true;
    if (this_present_pageMapped || that_present_pageMapped) {
      if (!(this_present_pageMapped && that_present_pageMapped))
        return false;
      if (this.pageMapped != that.pageMapped)
        return false;
    }

    boolean this_present_pageIn = true;
    boolean that_present_pageIn = true;
    if (this_present_pageIn || that_present_pageIn) {
      if (!(this_present_pageIn && that_present_pageIn))
        return false;
      if (this.pageIn != that.pageIn)
        return false;
    }

    boolean this_present_pageTrickle = true;
    boolean that_present_pageTrickle = true;
    if (this_present_pageTrickle || that_present_pageTrickle) {
      if (!(this_present_pageTrickle && that_present_pageTrickle))
        return false;
      if (this.pageTrickle != that.pageTrickle)
        return false;
    }

    boolean this_present_pageOut = true;
    boolean that_present_pageOut = true;
    if (this_present_pageOut || that_present_pageOut) {
      if (!(this_present_pageOut && that_present_pageOut))
        return false;
      if (this.pageOut != that.pageOut)
        return false;
    }

    boolean this_present_regionNowait = true;
    boolean that_present_regionNowait = true;
    if (this_present_regionNowait || that_present_regionNowait) {
      if (!(this_present_regionNowait && that_present_regionNowait))
        return false;
      if (this.regionNowait != that.regionNowait)
        return false;
    }

    boolean this_present_regionWait = true;
    boolean that_present_regionWait = true;
    if (this_present_regionWait || that_present_regionWait) {
      if (!(this_present_regionWait && that_present_regionWait))
        return false;
      if (this.regionWait != that.regionWait)
        return false;
    }

    boolean this_present_regmax = true;
    boolean that_present_regmax = true;
    if (this_present_regmax || that_present_regmax) {
      if (!(this_present_regmax && that_present_regmax))
        return false;
      if (this.regmax != that.regmax)
        return false;
    }

    boolean this_present_regSize = true;
    boolean that_present_regSize = true;
    if (this_present_regSize || that_present_regSize) {
      if (!(this_present_regSize && that_present_regSize))
        return false;
      if (this.regSize != that.regSize)
        return false;
    }

    boolean this_present_roEvict = true;
    boolean that_present_roEvict = true;
    if (this_present_roEvict || that_present_roEvict) {
      if (!(this_present_roEvict && that_present_roEvict))
        return false;
      if (this.roEvict != that.roEvict)
        return false;
    }

    boolean this_present_rwEvict = true;
    boolean that_present_rwEvict = true;
    if (this_present_rwEvict || that_present_rwEvict) {
      if (!(this_present_rwEvict && that_present_rwEvict))
        return false;
      if (this.rwEvict != that.rwEvict)
        return false;
    }

    boolean this_present_syncInterrupted = true;
    boolean that_present_syncInterrupted = true;
    if (this_present_syncInterrupted || that_present_syncInterrupted) {
      if (!(this_present_syncInterrupted && that_present_syncInterrupted))
        return false;
      if (this.syncInterrupted != that.syncInterrupted)
        return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    List<Object> list = new ArrayList<Object>();

    boolean present_alloc = true;
    list.add(present_alloc);
    if (present_alloc)
      list.add(alloc);

    boolean present_allocBuckets = true;
    list.add(present_allocBuckets);
    if (present_allocBuckets)
      list.add(allocBuckets);

    boolean present_allocMaxBuckets = true;
    list.add(present_allocMaxBuckets);
    if (present_allocMaxBuckets)
      list.add(allocMaxBuckets);

    boolean present_allocMaxPages = true;
    list.add(present_allocMaxPages);
    if (present_allocMaxPages)
      list.add(allocMaxPages);

    boolean present_allocPages = true;
    list.add(present_allocPages);
    if (present_allocPages)
      list.add(allocPages);

    boolean present_bytes = true;
    list.add(present_bytes);
    if (present_bytes)
      list.add(bytes);

    boolean present_cacheHit = true;
    list.add(present_cacheHit);
    if (present_cacheHit)
      list.add(cacheHit);

    boolean present_cacheMiss = true;
    list.add(present_cacheMiss);
    if (present_cacheMiss)
      list.add(cacheMiss);

    boolean present_gbytes = true;
    list.add(present_gbytes);
    if (present_gbytes)
      list.add(gbytes);

    boolean present_hashBuckets = true;
    list.add(present_hashBuckets);
    if (present_hashBuckets)
      list.add(hashBuckets);

    boolean present_hashExamined = true;
    list.add(present_hashExamined);
    if (present_hashExamined)
      list.add(hashExamined);

    boolean present_hashLongest = true;
    list.add(present_hashLongest);
    if (present_hashLongest)
      list.add(hashLongest);

    boolean present_hashMaxNowait = true;
    list.add(present_hashMaxNowait);
    if (present_hashMaxNowait)
      list.add(hashMaxNowait);

    boolean present_hashMaxWait = true;
    list.add(present_hashMaxWait);
    if (present_hashMaxWait)
      list.add(hashMaxWait);

    boolean present_hashMutexes = true;
    list.add(present_hashMutexes);
    if (present_hashMutexes)
      list.add(hashMutexes);

    boolean present_hashNowait = true;
    list.add(present_hashNowait);
    if (present_hashNowait)
      list.add(hashNowait);

    boolean present_hashSearches = true;
    list.add(present_hashSearches);
    if (present_hashSearches)
      list.add(hashSearches);

    boolean present_hashWait = true;
    list.add(present_hashWait);
    if (present_hashWait)
      list.add(hashWait);

    boolean present_ioWait = true;
    list.add(present_ioWait);
    if (present_ioWait)
      list.add(ioWait);

    boolean present_maxNumCache = true;
    list.add(present_maxNumCache);
    if (present_maxNumCache)
      list.add(maxNumCache);

    boolean present_maxOpenfd = true;
    list.add(present_maxOpenfd);
    if (present_maxOpenfd)
      list.add(maxOpenfd);

    boolean present_maxWrite = true;
    list.add(present_maxWrite);
    if (present_maxWrite)
      list.add(maxWrite);

    boolean present_maxWriteSleep = true;
    list.add(present_maxWriteSleep);
    if (present_maxWriteSleep)
      list.add(maxWriteSleep);

    boolean present_mmapSize = true;
    list.add(present_mmapSize);
    if (present_mmapSize)
      list.add(mmapSize);

    boolean present_multiversionFreed = true;
    list.add(present_multiversionFreed);
    if (present_multiversionFreed)
      list.add(multiversionFreed);

    boolean present_multiversionFrozen = true;
    list.add(present_multiversionFrozen);
    if (present_multiversionFrozen)
      list.add(multiversionFrozen);

    boolean present_multiversionReused = true;
    list.add(present_multiversionReused);
    if (present_multiversionReused)
      list.add(multiversionReused);

    boolean present_multiversionThawed = true;
    list.add(present_multiversionThawed);
    if (present_multiversionThawed)
      list.add(multiversionThawed);

    boolean present_numCache = true;
    list.add(present_numCache);
    if (present_numCache)
      list.add(numCache);

    boolean present_pages = true;
    list.add(present_pages);
    if (present_pages)
      list.add(pages);

    boolean present_pageSize = true;
    list.add(present_pageSize);
    if (present_pageSize)
      list.add(pageSize);

    boolean present_pageClean = true;
    list.add(present_pageClean);
    if (present_pageClean)
      list.add(pageClean);

    boolean present_pageCreate = true;
    list.add(present_pageCreate);
    if (present_pageCreate)
      list.add(pageCreate);

    boolean present_pageDirty = true;
    list.add(present_pageDirty);
    if (present_pageDirty)
      list.add(pageDirty);

    boolean present_pageMapped = true;
    list.add(present_pageMapped);
    if (present_pageMapped)
      list.add(pageMapped);

    boolean present_pageIn = true;
    list.add(present_pageIn);
    if (present_pageIn)
      list.add(pageIn);

    boolean present_pageTrickle = true;
    list.add(present_pageTrickle);
    if (present_pageTrickle)
      list.add(pageTrickle);

    boolean present_pageOut = true;
    list.add(present_pageOut);
    if (present_pageOut)
      list.add(pageOut);

    boolean present_regionNowait = true;
    list.add(present_regionNowait);
    if (present_regionNowait)
      list.add(regionNowait);

    boolean present_regionWait = true;
    list.add(present_regionWait);
    if (present_regionWait)
      list.add(regionWait);

    boolean present_regmax = true;
    list.add(present_regmax);
    if (present_regmax)
      list.add(regmax);

    boolean present_regSize = true;
    list.add(present_regSize);
    if (present_regSize)
      list.add(regSize);

    boolean present_roEvict = true;
    list.add(present_roEvict);
    if (present_roEvict)
      list.add(roEvict);

    boolean present_rwEvict = true;
    list.add(present_rwEvict);
    if (present_rwEvict)
      list.add(rwEvict);

    boolean present_syncInterrupted = true;
    list.add(present_syncInterrupted);
    if (present_syncInterrupted)
      list.add(syncInterrupted);

    return list.hashCode();
  }

  @Override
  public int compareTo(TCacheStat other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;

    lastComparison = Boolean.valueOf(isSetAlloc()).compareTo(other.isSetAlloc());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetAlloc()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.alloc, other.alloc);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetAllocBuckets()).compareTo(other.isSetAllocBuckets());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetAllocBuckets()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.allocBuckets, other.allocBuckets);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetAllocMaxBuckets()).compareTo(other.isSetAllocMaxBuckets());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetAllocMaxBuckets()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.allocMaxBuckets, other.allocMaxBuckets);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetAllocMaxPages()).compareTo(other.isSetAllocMaxPages());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetAllocMaxPages()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.allocMaxPages, other.allocMaxPages);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetAllocPages()).compareTo(other.isSetAllocPages());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetAllocPages()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.allocPages, other.allocPages);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetBytes()).compareTo(other.isSetBytes());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetBytes()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.bytes, other.bytes);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetCacheHit()).compareTo(other.isSetCacheHit());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCacheHit()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.cacheHit, other.cacheHit);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetCacheMiss()).compareTo(other.isSetCacheMiss());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCacheMiss()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.cacheMiss, other.cacheMiss);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetGbytes()).compareTo(other.isSetGbytes());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetGbytes()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.gbytes, other.gbytes);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetHashBuckets()).compareTo(other.isSetHashBuckets());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetHashBuckets()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.hashBuckets, other.hashBuckets);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetHashExamined()).compareTo(other.isSetHashExamined());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetHashExamined()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.hashExamined, other.hashExamined);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetHashLongest()).compareTo(other.isSetHashLongest());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetHashLongest()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.hashLongest, other.hashLongest);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetHashMaxNowait()).compareTo(other.isSetHashMaxNowait());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetHashMaxNowait()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.hashMaxNowait, other.hashMaxNowait);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetHashMaxWait()).compareTo(other.isSetHashMaxWait());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetHashMaxWait()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.hashMaxWait, other.hashMaxWait);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetHashMutexes()).compareTo(other.isSetHashMutexes());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetHashMutexes()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.hashMutexes, other.hashMutexes);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetHashNowait()).compareTo(other.isSetHashNowait());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetHashNowait()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.hashNowait, other.hashNowait);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetHashSearches()).compareTo(other.isSetHashSearches());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetHashSearches()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.hashSearches, other.hashSearches);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetHashWait()).compareTo(other.isSetHashWait());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetHashWait()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.hashWait, other.hashWait);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetIoWait()).compareTo(other.isSetIoWait());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetIoWait()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ioWait, other.ioWait);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMaxNumCache()).compareTo(other.isSetMaxNumCache());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMaxNumCache()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.maxNumCache, other.maxNumCache);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMaxOpenfd()).compareTo(other.isSetMaxOpenfd());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMaxOpenfd()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.maxOpenfd, other.maxOpenfd);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMaxWrite()).compareTo(other.isSetMaxWrite());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMaxWrite()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.maxWrite, other.maxWrite);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMaxWriteSleep()).compareTo(other.isSetMaxWriteSleep());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMaxWriteSleep()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.maxWriteSleep, other.maxWriteSleep);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMmapSize()).compareTo(other.isSetMmapSize());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMmapSize()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.mmapSize, other.mmapSize);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMultiversionFreed()).compareTo(other.isSetMultiversionFreed());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMultiversionFreed()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.multiversionFreed, other.multiversionFreed);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMultiversionFrozen()).compareTo(other.isSetMultiversionFrozen());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMultiversionFrozen()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.multiversionFrozen, other.multiversionFrozen);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMultiversionReused()).compareTo(other.isSetMultiversionReused());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMultiversionReused()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.multiversionReused, other.multiversionReused);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMultiversionThawed()).compareTo(other.isSetMultiversionThawed());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMultiversionThawed()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.multiversionThawed, other.multiversionThawed);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetNumCache()).compareTo(other.isSetNumCache());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetNumCache()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.numCache, other.numCache);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetPages()).compareTo(other.isSetPages());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetPages()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.pages, other.pages);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetPageSize()).compareTo(other.isSetPageSize());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetPageSize()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.pageSize, other.pageSize);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetPageClean()).compareTo(other.isSetPageClean());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetPageClean()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.pageClean, other.pageClean);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetPageCreate()).compareTo(other.isSetPageCreate());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetPageCreate()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.pageCreate, other.pageCreate);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetPageDirty()).compareTo(other.isSetPageDirty());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetPageDirty()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.pageDirty, other.pageDirty);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetPageMapped()).compareTo(other.isSetPageMapped());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetPageMapped()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.pageMapped, other.pageMapped);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetPageIn()).compareTo(other.isSetPageIn());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetPageIn()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.pageIn, other.pageIn);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetPageTrickle()).compareTo(other.isSetPageTrickle());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetPageTrickle()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.pageTrickle, other.pageTrickle);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetPageOut()).compareTo(other.isSetPageOut());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetPageOut()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.pageOut, other.pageOut);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRegionNowait()).compareTo(other.isSetRegionNowait());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRegionNowait()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.regionNowait, other.regionNowait);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRegionWait()).compareTo(other.isSetRegionWait());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRegionWait()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.regionWait, other.regionWait);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRegmax()).compareTo(other.isSetRegmax());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRegmax()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.regmax, other.regmax);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRegSize()).compareTo(other.isSetRegSize());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRegSize()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.regSize, other.regSize);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRoEvict()).compareTo(other.isSetRoEvict());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRoEvict()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.roEvict, other.roEvict);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRwEvict()).compareTo(other.isSetRwEvict());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRwEvict()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.rwEvict, other.rwEvict);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetSyncInterrupted()).compareTo(other.isSetSyncInterrupted());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetSyncInterrupted()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.syncInterrupted, other.syncInterrupted);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }

  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
  }

  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("TCacheStat(");
    boolean first = true;

    sb.append("alloc:");
    sb.append(this.alloc);
    first = false;
    if (!first) sb.append(", ");
    sb.append("allocBuckets:");
    sb.append(this.allocBuckets);
    first = false;
    if (!first) sb.append(", ");
    sb.append("allocMaxBuckets:");
    sb.append(this.allocMaxBuckets);
    first = false;
    if (!first) sb.append(", ");
    sb.append("allocMaxPages:");
    sb.append(this.allocMaxPages);
    first = false;
    if (!first) sb.append(", ");
    sb.append("allocPages:");
    sb.append(this.allocPages);
    first = false;
    if (!first) sb.append(", ");
    sb.append("bytes:");
    sb.append(this.bytes);
    first = false;
    if (!first) sb.append(", ");
    sb.append("cacheHit:");
    sb.append(this.cacheHit);
    first = false;
    if (!first) sb.append(", ");
    sb.append("cacheMiss:");
    sb.append(this.cacheMiss);
    first = false;
    if (!first) sb.append(", ");
    sb.append("gbytes:");
    sb.append(this.gbytes);
    first = false;
    if (!first) sb.append(", ");
    sb.append("hashBuckets:");
    sb.append(this.hashBuckets);
    first = false;
    if (!first) sb.append(", ");
    sb.append("hashExamined:");
    sb.append(this.hashExamined);
    first = false;
    if (!first) sb.append(", ");
    sb.append("hashLongest:");
    sb.append(this.hashLongest);
    first = false;
    if (!first) sb.append(", ");
    sb.append("hashMaxNowait:");
    sb.append(this.hashMaxNowait);
    first = false;
    if (!first) sb.append(", ");
    sb.append("hashMaxWait:");
    sb.append(this.hashMaxWait);
    first = false;
    if (!first) sb.append(", ");
    sb.append("hashMutexes:");
    sb.append(this.hashMutexes);
    first = false;
    if (!first) sb.append(", ");
    sb.append("hashNowait:");
    sb.append(this.hashNowait);
    first = false;
    if (!first) sb.append(", ");
    sb.append("hashSearches:");
    sb.append(this.hashSearches);
    first = false;
    if (!first) sb.append(", ");
    sb.append("hashWait:");
    sb.append(this.hashWait);
    first = false;
    if (!first) sb.append(", ");
    sb.append("ioWait:");
    sb.append(this.ioWait);
    first = false;
    if (!first) sb.append(", ");
    sb.append("maxNumCache:");
    sb.append(this.maxNumCache);
    first = false;
    if (!first) sb.append(", ");
    sb.append("maxOpenfd:");
    sb.append(this.maxOpenfd);
    first = false;
    if (!first) sb.append(", ");
    sb.append("maxWrite:");
    sb.append(this.maxWrite);
    first = false;
    if (!first) sb.append(", ");
    sb.append("maxWriteSleep:");
    sb.append(this.maxWriteSleep);
    first = false;
    if (!first) sb.append(", ");
    sb.append("mmapSize:");
    sb.append(this.mmapSize);
    first = false;
    if (!first) sb.append(", ");
    sb.append("multiversionFreed:");
    sb.append(this.multiversionFreed);
    first = false;
    if (!first) sb.append(", ");
    sb.append("multiversionFrozen:");
    sb.append(this.multiversionFrozen);
    first = false;
    if (!first) sb.append(", ");
    sb.append("multiversionReused:");
    sb.append(this.multiversionReused);
    first = false;
    if (!first) sb.append(", ");
    sb.append("multiversionThawed:");
    sb.append(this.multiversionThawed);
    first = false;
    if (!first) sb.append(", ");
    sb.append("numCache:");
    sb.append(this.numCache);
    first = false;
    if (!first) sb.append(", ");
    sb.append("pages:");
    sb.append(this.pages);
    first = false;
    if (!first) sb.append(", ");
    sb.append("pageSize:");
    sb.append(this.pageSize);
    first = false;
    if (!first) sb.append(", ");
    sb.append("pageClean:");
    sb.append(this.pageClean);
    first = false;
    if (!first) sb.append(", ");
    sb.append("pageCreate:");
    sb.append(this.pageCreate);
    first = false;
    if (!first) sb.append(", ");
    sb.append("pageDirty:");
    sb.append(this.pageDirty);
    first = false;
    if (!first) sb.append(", ");
    sb.append("pageMapped:");
    sb.append(this.pageMapped);
    first = false;
    if (!first) sb.append(", ");
    sb.append("pageIn:");
    sb.append(this.pageIn);
    first = false;
    if (!first) sb.append(", ");
    sb.append("pageTrickle:");
    sb.append(this.pageTrickle);
    first = false;
    if (!first) sb.append(", ");
    sb.append("pageOut:");
    sb.append(this.pageOut);
    first = false;
    if (!first) sb.append(", ");
    sb.append("regionNowait:");
    sb.append(this.regionNowait);
    first = false;
    if (!first) sb.append(", ");
    sb.append("regionWait:");
    sb.append(this.regionWait);
    first = false;
    if (!first) sb.append(", ");
    sb.append("regmax:");
    sb.append(this.regmax);
    first = false;
    if (!first) sb.append(", ");
    sb.append("regSize:");
    sb.append(this.regSize);
    first = false;
    if (!first) sb.append(", ");
    sb.append("roEvict:");
    sb.append(this.roEvict);
    first = false;
    if (!first) sb.append(", ");
    sb.append("rwEvict:");
    sb.append(this.rwEvict);
    first = false;
    if (!first) sb.append(", ");
    sb.append("syncInterrupted:");
    sb.append(this.syncInterrupted);
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws org.apache.thrift.TException {
    // check for required fields
    // check for sub-struct validity
  }

  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
    try {
      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
    try {
      // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
      __isset_bitfield = 0;
      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private static class TCacheStatStandardSchemeFactory implements SchemeFactory {
    public TCacheStatStandardScheme getScheme() {
      return new TCacheStatStandardScheme();
    }
  }

  private static class TCacheStatStandardScheme extends StandardScheme<TCacheStat> {

    public void read(org.apache.thrift.protocol.TProtocol iprot, TCacheStat struct) throws org.apache.thrift.TException {
      org.apache.thrift.protocol.TField schemeField;
      iprot.readStructBegin();
      while (true)
      {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (schemeField.id) {
          case 1: // ALLOC
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.alloc = iprot.readI64();
              struct.setAllocIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 2: // ALLOC_BUCKETS
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.allocBuckets = iprot.readI64();
              struct.setAllocBucketsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 3: // ALLOC_MAX_BUCKETS
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.allocMaxBuckets = iprot.readI64();
              struct.setAllocMaxBucketsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 4: // ALLOC_MAX_PAGES
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.allocMaxPages = iprot.readI64();
              struct.setAllocMaxPagesIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 5: // ALLOC_PAGES
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.allocPages = iprot.readI64();
              struct.setAllocPagesIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 6: // BYTES
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.bytes = iprot.readI32();
              struct.setBytesIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 7: // CACHE_HIT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.cacheHit = iprot.readI64();
              struct.setCacheHitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 8: // CACHE_MISS
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.cacheMiss = iprot.readI64();
              struct.setCacheMissIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 9: // GBYTES
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.gbytes = iprot.readI32();
              struct.setGbytesIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 10: // HASH_BUCKETS
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.hashBuckets = iprot.readI32();
              struct.setHashBucketsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 11: // HASH_EXAMINED
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.hashExamined = iprot.readI64();
              struct.setHashExaminedIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 12: // HASH_LONGEST
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.hashLongest = iprot.readI32();
              struct.setHashLongestIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 13: // HASH_MAX_NOWAIT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.hashMaxNowait = iprot.readI64();
              struct.setHashMaxNowaitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 14: // HASH_MAX_WAIT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.hashMaxWait = iprot.readI64();
              struct.setHashMaxWaitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 15: // HASH_MUTEXES
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.hashMutexes = iprot.readI32();
              struct.setHashMutexesIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 16: // HASH_NOWAIT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.hashNowait = iprot.readI64();
              struct.setHashNowaitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 17: // HASH_SEARCHES
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.hashSearches = iprot.readI32();
              struct.setHashSearchesIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 18: // HASH_WAIT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.hashWait = iprot.readI64();
              struct.setHashWaitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 19: // IO_WAIT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.ioWait = iprot.readI64();
              struct.setIoWaitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 20: // MAX_NUM_CACHE
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.maxNumCache = iprot.readI32();
              struct.setMaxNumCacheIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 21: // MAX_OPENFD
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.maxOpenfd = iprot.readI32();
              struct.setMaxOpenfdIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 22: // MAX_WRITE
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.maxWrite = iprot.readI32();
              struct.setMaxWriteIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 23: // MAX_WRITE_SLEEP
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.maxWriteSleep = iprot.readI32();
              struct.setMaxWriteSleepIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 24: // MMAP_SIZE
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.mmapSize = iprot.readI64();
              struct.setMmapSizeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 25: // MULTIVERSION_FREED
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.multiversionFreed = iprot.readI64();
              struct.setMultiversionFreedIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 26: // MULTIVERSION_FROZEN
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.multiversionFrozen = iprot.readI64();
              struct.setMultiversionFrozenIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 27: // MULTIVERSION_REUSED
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.multiversionReused = iprot.readI64();
              struct.setMultiversionReusedIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 28: // MULTIVERSION_THAWED
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.multiversionThawed = iprot.readI64();
              struct.setMultiversionThawedIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 29: // NUM_CACHE
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.numCache = iprot.readI32();
              struct.setNumCacheIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 30: // PAGES
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.pages = iprot.readI32();
              struct.setPagesIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 31: // PAGE_SIZE
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.pageSize = iprot.readI32();
              struct.setPageSizeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 32: // PAGE_CLEAN
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.pageClean = iprot.readI32();
              struct.setPageCleanIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 33: // PAGE_CREATE
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.pageCreate = iprot.readI64();
              struct.setPageCreateIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 34: // PAGE_DIRTY
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.pageDirty = iprot.readI32();
              struct.setPageDirtyIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 35: // PAGE_MAPPED
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.pageMapped = iprot.readI32();
              struct.setPageMappedIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 36: // PAGE_IN
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.pageIn = iprot.readI64();
              struct.setPageInIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 37: // PAGE_TRICKLE
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.pageTrickle = iprot.readI64();
              struct.setPageTrickleIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 38: // PAGE_OUT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.pageOut = iprot.readI64();
              struct.setPageOutIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 39: // REGION_NOWAIT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.regionNowait = iprot.readI64();
              struct.setRegionNowaitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 40: // REGION_WAIT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.regionWait = iprot.readI64();
              struct.setRegionWaitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 41: // REGMAX
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.regmax = iprot.readI64();
              struct.setRegmaxIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 42: // REG_SIZE
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.regSize = iprot.readI64();
              struct.setRegSizeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 43: // RO_EVICT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.roEvict = iprot.readI64();
              struct.setRoEvictIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 44: // RW_EVICT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.rwEvict = iprot.readI64();
              struct.setRwEvictIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 45: // SYNC_INTERRUPTED
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.syncInterrupted = iprot.readI64();
              struct.setSyncInterruptedIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      struct.validate();
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot, TCacheStat struct) throws org.apache.thrift.TException {
      struct.validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(ALLOC_FIELD_DESC);
      oprot.writeI64(struct.alloc);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(ALLOC_BUCKETS_FIELD_DESC);
      oprot.writeI64(struct.allocBuckets);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(ALLOC_MAX_BUCKETS_FIELD_DESC);
      oprot.writeI64(struct.allocMaxBuckets);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(ALLOC_MAX_PAGES_FIELD_DESC);
      oprot.writeI64(struct.allocMaxPages);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(ALLOC_PAGES_FIELD_DESC);
      oprot.writeI64(struct.allocPages);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(BYTES_FIELD_DESC);
      oprot.writeI32(struct.bytes);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(CACHE_HIT_FIELD_DESC);
      oprot.writeI64(struct.cacheHit);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(CACHE_MISS_FIELD_DESC);
      oprot.writeI64(struct.cacheMiss);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(GBYTES_FIELD_DESC);
      oprot.writeI32(struct.gbytes);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(HASH_BUCKETS_FIELD_DESC);
      oprot.writeI32(struct.hashBuckets);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(HASH_EXAMINED_FIELD_DESC);
      oprot.writeI64(struct.hashExamined);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(HASH_LONGEST_FIELD_DESC);
      oprot.writeI32(struct.hashLongest);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(HASH_MAX_NOWAIT_FIELD_DESC);
      oprot.writeI64(struct.hashMaxNowait);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(HASH_MAX_WAIT_FIELD_DESC);
      oprot.writeI64(struct.hashMaxWait);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(HASH_MUTEXES_FIELD_DESC);
      oprot.writeI32(struct.hashMutexes);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(HASH_NOWAIT_FIELD_DESC);
      oprot.writeI64(struct.hashNowait);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(HASH_SEARCHES_FIELD_DESC);
      oprot.writeI32(struct.hashSearches);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(HASH_WAIT_FIELD_DESC);
      oprot.writeI64(struct.hashWait);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(IO_WAIT_FIELD_DESC);
      oprot.writeI64(struct.ioWait);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MAX_NUM_CACHE_FIELD_DESC);
      oprot.writeI32(struct.maxNumCache);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MAX_OPENFD_FIELD_DESC);
      oprot.writeI32(struct.maxOpenfd);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MAX_WRITE_FIELD_DESC);
      oprot.writeI32(struct.maxWrite);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MAX_WRITE_SLEEP_FIELD_DESC);
      oprot.writeI32(struct.maxWriteSleep);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MMAP_SIZE_FIELD_DESC);
      oprot.writeI64(struct.mmapSize);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MULTIVERSION_FREED_FIELD_DESC);
      oprot.writeI64(struct.multiversionFreed);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MULTIVERSION_FROZEN_FIELD_DESC);
      oprot.writeI64(struct.multiversionFrozen);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MULTIVERSION_REUSED_FIELD_DESC);
      oprot.writeI64(struct.multiversionReused);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MULTIVERSION_THAWED_FIELD_DESC);
      oprot.writeI64(struct.multiversionThawed);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(NUM_CACHE_FIELD_DESC);
      oprot.writeI32(struct.numCache);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(PAGES_FIELD_DESC);
      oprot.writeI32(struct.pages);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(PAGE_SIZE_FIELD_DESC);
      oprot.writeI32(struct.pageSize);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(PAGE_CLEAN_FIELD_DESC);
      oprot.writeI32(struct.pageClean);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(PAGE_CREATE_FIELD_DESC);
      oprot.writeI64(struct.pageCreate);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(PAGE_DIRTY_FIELD_DESC);
      oprot.writeI32(struct.pageDirty);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(PAGE_MAPPED_FIELD_DESC);
      oprot.writeI32(struct.pageMapped);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(PAGE_IN_FIELD_DESC);
      oprot.writeI64(struct.pageIn);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(PAGE_TRICKLE_FIELD_DESC);
      oprot.writeI64(struct.pageTrickle);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(PAGE_OUT_FIELD_DESC);
      oprot.writeI64(struct.pageOut);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(REGION_NOWAIT_FIELD_DESC);
      oprot.writeI64(struct.regionNowait);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(REGION_WAIT_FIELD_DESC);
      oprot.writeI64(struct.regionWait);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(REGMAX_FIELD_DESC);
      oprot.writeI64(struct.regmax);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(REG_SIZE_FIELD_DESC);
      oprot.writeI64(struct.regSize);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(RO_EVICT_FIELD_DESC);
      oprot.writeI64(struct.roEvict);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(RW_EVICT_FIELD_DESC);
      oprot.writeI64(struct.rwEvict);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(SYNC_INTERRUPTED_FIELD_DESC);
      oprot.writeI64(struct.syncInterrupted);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

  }

  private static class TCacheStatTupleSchemeFactory implements SchemeFactory {
    public TCacheStatTupleScheme getScheme() {
      return new TCacheStatTupleScheme();
    }
  }

  private static class TCacheStatTupleScheme extends TupleScheme<TCacheStat> {

    @Override
    public void write(org.apache.thrift.protocol.TProtocol prot, TCacheStat struct) throws org.apache.thrift.TException {
      TTupleProtocol oprot = (TTupleProtocol) prot;
      BitSet optionals = new BitSet();
      if (struct.isSetAlloc()) {
        optionals.set(0);
      }
      if (struct.isSetAllocBuckets()) {
        optionals.set(1);
      }
      if (struct.isSetAllocMaxBuckets()) {
        optionals.set(2);
      }
      if (struct.isSetAllocMaxPages()) {
        optionals.set(3);
      }
      if (struct.isSetAllocPages()) {
        optionals.set(4);
      }
      if (struct.isSetBytes()) {
        optionals.set(5);
      }
      if (struct.isSetCacheHit()) {
        optionals.set(6);
      }
      if (struct.isSetCacheMiss()) {
        optionals.set(7);
      }
      if (struct.isSetGbytes()) {
        optionals.set(8);
      }
      if (struct.isSetHashBuckets()) {
        optionals.set(9);
      }
      if (struct.isSetHashExamined()) {
        optionals.set(10);
      }
      if (struct.isSetHashLongest()) {
        optionals.set(11);
      }
      if (struct.isSetHashMaxNowait()) {
        optionals.set(12);
      }
      if (struct.isSetHashMaxWait()) {
        optionals.set(13);
      }
      if (struct.isSetHashMutexes()) {
        optionals.set(14);
      }
      if (struct.isSetHashNowait()) {
        optionals.set(15);
      }
      if (struct.isSetHashSearches()) {
        optionals.set(16);
      }
      if (struct.isSetHashWait()) {
        optionals.set(17);
      }
      if (struct.isSetIoWait()) {
        optionals.set(18);
      }
      if (struct.isSetMaxNumCache()) {
        optionals.set(19);
      }
      if (struct.isSetMaxOpenfd()) {
        optionals.set(20);
      }
      if (struct.isSetMaxWrite()) {
        optionals.set(21);
      }
      if (struct.isSetMaxWriteSleep()) {
        optionals.set(22);
      }
      if (struct.isSetMmapSize()) {
        optionals.set(23);
      }
      if (struct.isSetMultiversionFreed()) {
        optionals.set(24);
      }
      if (struct.isSetMultiversionFrozen()) {
        optionals.set(25);
      }
      if (struct.isSetMultiversionReused()) {
        optionals.set(26);
      }
      if (struct.isSetMultiversionThawed()) {
        optionals.set(27);
      }
      if (struct.isSetNumCache()) {
        optionals.set(28);
      }
      if (struct.isSetPages()) {
        optionals.set(29);
      }
      if (struct.isSetPageSize()) {
        optionals.set(30);
      }
      if (struct.isSetPageClean()) {
        optionals.set(31);
      }
      if (struct.isSetPageCreate()) {
        optionals.set(32);
      }
      if (struct.isSetPageDirty()) {
        optionals.set(33);
      }
      if (struct.isSetPageMapped()) {
        optionals.set(34);
      }
      if (struct.isSetPageIn()) {
        optionals.set(35);
      }
      if (struct.isSetPageTrickle()) {
        optionals.set(36);
      }
      if (struct.isSetPageOut()) {
        optionals.set(37);
      }
      if (struct.isSetRegionNowait()) {
        optionals.set(38);
      }
      if (struct.isSetRegionWait()) {
        optionals.set(39);
      }
      if (struct.isSetRegmax()) {
        optionals.set(40);
      }
      if (struct.isSetRegSize()) {
        optionals.set(41);
      }
      if (struct.isSetRoEvict()) {
        optionals.set(42);
      }
      if (struct.isSetRwEvict()) {
        optionals.set(43);
      }
      if (struct.isSetSyncInterrupted()) {
        optionals.set(44);
      }
      oprot.writeBitSet(optionals, 45);
      if (struct.isSetAlloc()) {
        oprot.writeI64(struct.alloc);
      }
      if (struct.isSetAllocBuckets()) {
        oprot.writeI64(struct.allocBuckets);
      }
      if (struct.isSetAllocMaxBuckets()) {
        oprot.writeI64(struct.allocMaxBuckets);
      }
      if (struct.isSetAllocMaxPages()) {
        oprot.writeI64(struct.allocMaxPages);
      }
      if (struct.isSetAllocPages()) {
        oprot.writeI64(struct.allocPages);
      }
      if (struct.isSetBytes()) {
        oprot.writeI32(struct.bytes);
      }
      if (struct.isSetCacheHit()) {
        oprot.writeI64(struct.cacheHit);
      }
      if (struct.isSetCacheMiss()) {
        oprot.writeI64(struct.cacheMiss);
      }
      if (struct.isSetGbytes()) {
        oprot.writeI32(struct.gbytes);
      }
      if (struct.isSetHashBuckets()) {
        oprot.writeI32(struct.hashBuckets);
      }
      if (struct.isSetHashExamined()) {
        oprot.writeI64(struct.hashExamined);
      }
      if (struct.isSetHashLongest()) {
        oprot.writeI32(struct.hashLongest);
      }
      if (struct.isSetHashMaxNowait()) {
        oprot.writeI64(struct.hashMaxNowait);
      }
      if (struct.isSetHashMaxWait()) {
        oprot.writeI64(struct.hashMaxWait);
      }
      if (struct.isSetHashMutexes()) {
        oprot.writeI32(struct.hashMutexes);
      }
      if (struct.isSetHashNowait()) {
        oprot.writeI64(struct.hashNowait);
      }
      if (struct.isSetHashSearches()) {
        oprot.writeI32(struct.hashSearches);
      }
      if (struct.isSetHashWait()) {
        oprot.writeI64(struct.hashWait);
      }
      if (struct.isSetIoWait()) {
        oprot.writeI64(struct.ioWait);
      }
      if (struct.isSetMaxNumCache()) {
        oprot.writeI32(struct.maxNumCache);
      }
      if (struct.isSetMaxOpenfd()) {
        oprot.writeI32(struct.maxOpenfd);
      }
      if (struct.isSetMaxWrite()) {
        oprot.writeI32(struct.maxWrite);
      }
      if (struct.isSetMaxWriteSleep()) {
        oprot.writeI32(struct.maxWriteSleep);
      }
      if (struct.isSetMmapSize()) {
        oprot.writeI64(struct.mmapSize);
      }
      if (struct.isSetMultiversionFreed()) {
        oprot.writeI64(struct.multiversionFreed);
      }
      if (struct.isSetMultiversionFrozen()) {
        oprot.writeI64(struct.multiversionFrozen);
      }
      if (struct.isSetMultiversionReused()) {
        oprot.writeI64(struct.multiversionReused);
      }
      if (struct.isSetMultiversionThawed()) {
        oprot.writeI64(struct.multiversionThawed);
      }
      if (struct.isSetNumCache()) {
        oprot.writeI32(struct.numCache);
      }
      if (struct.isSetPages()) {
        oprot.writeI32(struct.pages);
      }
      if (struct.isSetPageSize()) {
        oprot.writeI32(struct.pageSize);
      }
      if (struct.isSetPageClean()) {
        oprot.writeI32(struct.pageClean);
      }
      if (struct.isSetPageCreate()) {
        oprot.writeI64(struct.pageCreate);
      }
      if (struct.isSetPageDirty()) {
        oprot.writeI32(struct.pageDirty);
      }
      if (struct.isSetPageMapped()) {
        oprot.writeI32(struct.pageMapped);
      }
      if (struct.isSetPageIn()) {
        oprot.writeI64(struct.pageIn);
      }
      if (struct.isSetPageTrickle()) {
        oprot.writeI64(struct.pageTrickle);
      }
      if (struct.isSetPageOut()) {
        oprot.writeI64(struct.pageOut);
      }
      if (struct.isSetRegionNowait()) {
        oprot.writeI64(struct.regionNowait);
      }
      if (struct.isSetRegionWait()) {
        oprot.writeI64(struct.regionWait);
      }
      if (struct.isSetRegmax()) {
        oprot.writeI64(struct.regmax);
      }
      if (struct.isSetRegSize()) {
        oprot.writeI64(struct.regSize);
      }
      if (struct.isSetRoEvict()) {
        oprot.writeI64(struct.roEvict);
      }
      if (struct.isSetRwEvict()) {
        oprot.writeI64(struct.rwEvict);
      }
      if (struct.isSetSyncInterrupted()) {
        oprot.writeI64(struct.syncInterrupted);
      }
    }

    @Override
    public void read(org.apache.thrift.protocol.TProtocol prot, TCacheStat struct) throws org.apache.thrift.TException {
      TTupleProtocol iprot = (TTupleProtocol) prot;
      BitSet incoming = iprot.readBitSet(45);
      if (incoming.get(0)) {
        struct.alloc = iprot.readI64();
        struct.setAllocIsSet(true);
      }
      if (incoming.get(1)) {
        struct.allocBuckets = iprot.readI64();
        struct.setAllocBucketsIsSet(true);
      }
      if (incoming.get(2)) {
        struct.allocMaxBuckets = iprot.readI64();
        struct.setAllocMaxBucketsIsSet(true);
      }
      if (incoming.get(3)) {
        struct.allocMaxPages = iprot.readI64();
        struct.setAllocMaxPagesIsSet(true);
      }
      if (incoming.get(4)) {
        struct.allocPages = iprot.readI64();
        struct.setAllocPagesIsSet(true);
      }
      if (incoming.get(5)) {
        struct.bytes = iprot.readI32();
        struct.setBytesIsSet(true);
      }
      if (incoming.get(6)) {
        struct.cacheHit = iprot.readI64();
        struct.setCacheHitIsSet(true);
      }
      if (incoming.get(7)) {
        struct.cacheMiss = iprot.readI64();
        struct.setCacheMissIsSet(true);
      }
      if (incoming.get(8)) {
        struct.gbytes = iprot.readI32();
        struct.setGbytesIsSet(true);
      }
      if (incoming.get(9)) {
        struct.hashBuckets = iprot.readI32();
        struct.setHashBucketsIsSet(true);
      }
      if (incoming.get(10)) {
        struct.hashExamined = iprot.readI64();
        struct.setHashExaminedIsSet(true);
      }
      if (incoming.get(11)) {
        struct.hashLongest = iprot.readI32();
        struct.setHashLongestIsSet(true);
      }
      if (incoming.get(12)) {
        struct.hashMaxNowait = iprot.readI64();
        struct.setHashMaxNowaitIsSet(true);
      }
      if (incoming.get(13)) {
        struct.hashMaxWait = iprot.readI64();
        struct.setHashMaxWaitIsSet(true);
      }
      if (incoming.get(14)) {
        struct.hashMutexes = iprot.readI32();
        struct.setHashMutexesIsSet(true);
      }
      if (incoming.get(15)) {
        struct.hashNowait = iprot.readI64();
        struct.setHashNowaitIsSet(true);
      }
      if (incoming.get(16)) {
        struct.hashSearches = iprot.readI32();
        struct.setHashSearchesIsSet(true);
      }
      if (incoming.get(17)) {
        struct.hashWait = iprot.readI64();
        struct.setHashWaitIsSet(true);
      }
      if (incoming.get(18)) {
        struct.ioWait = iprot.readI64();
        struct.setIoWaitIsSet(true);
      }
      if (incoming.get(19)) {
        struct.maxNumCache = iprot.readI32();
        struct.setMaxNumCacheIsSet(true);
      }
      if (incoming.get(20)) {
        struct.maxOpenfd = iprot.readI32();
        struct.setMaxOpenfdIsSet(true);
      }
      if (incoming.get(21)) {
        struct.maxWrite = iprot.readI32();
        struct.setMaxWriteIsSet(true);
      }
      if (incoming.get(22)) {
        struct.maxWriteSleep = iprot.readI32();
        struct.setMaxWriteSleepIsSet(true);
      }
      if (incoming.get(23)) {
        struct.mmapSize = iprot.readI64();
        struct.setMmapSizeIsSet(true);
      }
      if (incoming.get(24)) {
        struct.multiversionFreed = iprot.readI64();
        struct.setMultiversionFreedIsSet(true);
      }
      if (incoming.get(25)) {
        struct.multiversionFrozen = iprot.readI64();
        struct.setMultiversionFrozenIsSet(true);
      }
      if (incoming.get(26)) {
        struct.multiversionReused = iprot.readI64();
        struct.setMultiversionReusedIsSet(true);
      }
      if (incoming.get(27)) {
        struct.multiversionThawed = iprot.readI64();
        struct.setMultiversionThawedIsSet(true);
      }
      if (incoming.get(28)) {
        struct.numCache = iprot.readI32();
        struct.setNumCacheIsSet(true);
      }
      if (incoming.get(29)) {
        struct.pages = iprot.readI32();
        struct.setPagesIsSet(true);
      }
      if (incoming.get(30)) {
        struct.pageSize = iprot.readI32();
        struct.setPageSizeIsSet(true);
      }
      if (incoming.get(31)) {
        struct.pageClean = iprot.readI32();
        struct.setPageCleanIsSet(true);
      }
      if (incoming.get(32)) {
        struct.pageCreate = iprot.readI64();
        struct.setPageCreateIsSet(true);
      }
      if (incoming.get(33)) {
        struct.pageDirty = iprot.readI32();
        struct.setPageDirtyIsSet(true);
      }
      if (incoming.get(34)) {
        struct.pageMapped = iprot.readI32();
        struct.setPageMappedIsSet(true);
      }
      if (incoming.get(35)) {
        struct.pageIn = iprot.readI64();
        struct.setPageInIsSet(true);
      }
      if (incoming.get(36)) {
        struct.pageTrickle = iprot.readI64();
        struct.setPageTrickleIsSet(true);
      }
      if (incoming.get(37)) {
        struct.pageOut = iprot.readI64();
        struct.setPageOutIsSet(true);
      }
      if (incoming.get(38)) {
        struct.regionNowait = iprot.readI64();
        struct.setRegionNowaitIsSet(true);
      }
      if (incoming.get(39)) {
        struct.regionWait = iprot.readI64();
        struct.setRegionWaitIsSet(true);
      }
      if (incoming.get(40)) {
        struct.regmax = iprot.readI64();
        struct.setRegmaxIsSet(true);
      }
      if (incoming.get(41)) {
        struct.regSize = iprot.readI64();
        struct.setRegSizeIsSet(true);
      }
      if (incoming.get(42)) {
        struct.roEvict = iprot.readI64();
        struct.setRoEvictIsSet(true);
      }
      if (incoming.get(43)) {
        struct.rwEvict = iprot.readI64();
        struct.setRwEvictIsSet(true);
      }
      if (incoming.get(44)) {
        struct.syncInterrupted = iprot.readI64();
        struct.setSyncInterruptedIsSet(true);
      }
    }
  }

}

