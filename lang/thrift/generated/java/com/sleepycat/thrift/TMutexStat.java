/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.sleepycat.thrift;

import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import org.apache.thrift.async.AsyncMethodCallback;
import org.apache.thrift.server.AbstractNonblockingServer.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import javax.annotation.Generated;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
@Generated(value = "Autogenerated by Thrift Compiler (0.9.2)", date = "2015-10-9")
public class TMutexStat implements org.apache.thrift.TBase<TMutexStat, TMutexStat._Fields>, java.io.Serializable, Cloneable, Comparable<TMutexStat> {
  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TMutexStat");

  private static final org.apache.thrift.protocol.TField MUTEX_ALIGN_FIELD_DESC = new org.apache.thrift.protocol.TField("mutexAlign", org.apache.thrift.protocol.TType.I32, (short)1);
  private static final org.apache.thrift.protocol.TField MUTEX_COUNT_FIELD_DESC = new org.apache.thrift.protocol.TField("mutexCount", org.apache.thrift.protocol.TType.I32, (short)2);
  private static final org.apache.thrift.protocol.TField MUTEX_FREE_FIELD_DESC = new org.apache.thrift.protocol.TField("mutexFree", org.apache.thrift.protocol.TType.I32, (short)3);
  private static final org.apache.thrift.protocol.TField MUTEX_INIT_FIELD_DESC = new org.apache.thrift.protocol.TField("mutexInit", org.apache.thrift.protocol.TType.I32, (short)4);
  private static final org.apache.thrift.protocol.TField MUTEX_INUSE_FIELD_DESC = new org.apache.thrift.protocol.TField("mutexInuse", org.apache.thrift.protocol.TType.I32, (short)5);
  private static final org.apache.thrift.protocol.TField MUTEX_INUSE_MAX_FIELD_DESC = new org.apache.thrift.protocol.TField("mutexInuseMax", org.apache.thrift.protocol.TType.I32, (short)6);
  private static final org.apache.thrift.protocol.TField MUTEX_MAX_FIELD_DESC = new org.apache.thrift.protocol.TField("mutexMax", org.apache.thrift.protocol.TType.I32, (short)7);
  private static final org.apache.thrift.protocol.TField MUTEX_TAS_SPINS_FIELD_DESC = new org.apache.thrift.protocol.TField("mutexTasSpins", org.apache.thrift.protocol.TType.I32, (short)8);
  private static final org.apache.thrift.protocol.TField REGION_NOWAIT_FIELD_DESC = new org.apache.thrift.protocol.TField("regionNowait", org.apache.thrift.protocol.TType.I64, (short)9);
  private static final org.apache.thrift.protocol.TField REGION_WAIT_FIELD_DESC = new org.apache.thrift.protocol.TField("regionWait", org.apache.thrift.protocol.TType.I64, (short)10);
  private static final org.apache.thrift.protocol.TField REGMAX_FIELD_DESC = new org.apache.thrift.protocol.TField("regmax", org.apache.thrift.protocol.TType.I64, (short)11);
  private static final org.apache.thrift.protocol.TField REG_SIZE_FIELD_DESC = new org.apache.thrift.protocol.TField("regSize", org.apache.thrift.protocol.TType.I64, (short)12);

  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
  static {
    schemes.put(StandardScheme.class, new TMutexStatStandardSchemeFactory());
    schemes.put(TupleScheme.class, new TMutexStatTupleSchemeFactory());
  }

  public int mutexAlign; // required
  public int mutexCount; // required
  public int mutexFree; // required
  public int mutexInit; // required
  public int mutexInuse; // required
  public int mutexInuseMax; // required
  public int mutexMax; // required
  public int mutexTasSpins; // required
  public long regionNowait; // required
  public long regionWait; // required
  public long regmax; // required
  public long regSize; // required

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
    MUTEX_ALIGN((short)1, "mutexAlign"),
    MUTEX_COUNT((short)2, "mutexCount"),
    MUTEX_FREE((short)3, "mutexFree"),
    MUTEX_INIT((short)4, "mutexInit"),
    MUTEX_INUSE((short)5, "mutexInuse"),
    MUTEX_INUSE_MAX((short)6, "mutexInuseMax"),
    MUTEX_MAX((short)7, "mutexMax"),
    MUTEX_TAS_SPINS((short)8, "mutexTasSpins"),
    REGION_NOWAIT((short)9, "regionNowait"),
    REGION_WAIT((short)10, "regionWait"),
    REGMAX((short)11, "regmax"),
    REG_SIZE((short)12, "regSize");

    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // MUTEX_ALIGN
          return MUTEX_ALIGN;
        case 2: // MUTEX_COUNT
          return MUTEX_COUNT;
        case 3: // MUTEX_FREE
          return MUTEX_FREE;
        case 4: // MUTEX_INIT
          return MUTEX_INIT;
        case 5: // MUTEX_INUSE
          return MUTEX_INUSE;
        case 6: // MUTEX_INUSE_MAX
          return MUTEX_INUSE_MAX;
        case 7: // MUTEX_MAX
          return MUTEX_MAX;
        case 8: // MUTEX_TAS_SPINS
          return MUTEX_TAS_SPINS;
        case 9: // REGION_NOWAIT
          return REGION_NOWAIT;
        case 10: // REGION_WAIT
          return REGION_WAIT;
        case 11: // REGMAX
          return REGMAX;
        case 12: // REG_SIZE
          return REG_SIZE;
        default:
          return null;
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }

    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }

    private final short _thriftId;
    private final String _fieldName;

    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }

    public short getThriftFieldId() {
      return _thriftId;
    }

    public String getFieldName() {
      return _fieldName;
    }
  }

  // isset id assignments
  private static final int __MUTEXALIGN_ISSET_ID = 0;
  private static final int __MUTEXCOUNT_ISSET_ID = 1;
  private static final int __MUTEXFREE_ISSET_ID = 2;
  private static final int __MUTEXINIT_ISSET_ID = 3;
  private static final int __MUTEXINUSE_ISSET_ID = 4;
  private static final int __MUTEXINUSEMAX_ISSET_ID = 5;
  private static final int __MUTEXMAX_ISSET_ID = 6;
  private static final int __MUTEXTASSPINS_ISSET_ID = 7;
  private static final int __REGIONNOWAIT_ISSET_ID = 8;
  private static final int __REGIONWAIT_ISSET_ID = 9;
  private static final int __REGMAX_ISSET_ID = 10;
  private static final int __REGSIZE_ISSET_ID = 11;
  private short __isset_bitfield = 0;
  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
  static {
    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.MUTEX_ALIGN, new org.apache.thrift.meta_data.FieldMetaData("mutexAlign", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MUTEX_COUNT, new org.apache.thrift.meta_data.FieldMetaData("mutexCount", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MUTEX_FREE, new org.apache.thrift.meta_data.FieldMetaData("mutexFree", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MUTEX_INIT, new org.apache.thrift.meta_data.FieldMetaData("mutexInit", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MUTEX_INUSE, new org.apache.thrift.meta_data.FieldMetaData("mutexInuse", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MUTEX_INUSE_MAX, new org.apache.thrift.meta_data.FieldMetaData("mutexInuseMax", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MUTEX_MAX, new org.apache.thrift.meta_data.FieldMetaData("mutexMax", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MUTEX_TAS_SPINS, new org.apache.thrift.meta_data.FieldMetaData("mutexTasSpins", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.REGION_NOWAIT, new org.apache.thrift.meta_data.FieldMetaData("regionNowait", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.REGION_WAIT, new org.apache.thrift.meta_data.FieldMetaData("regionWait", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.REGMAX, new org.apache.thrift.meta_data.FieldMetaData("regmax", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.REG_SIZE, new org.apache.thrift.meta_data.FieldMetaData("regSize", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(TMutexStat.class, metaDataMap);
  }

  public TMutexStat() {
  }

  public TMutexStat(
    int mutexAlign,
    int mutexCount,
    int mutexFree,
    int mutexInit,
    int mutexInuse,
    int mutexInuseMax,
    int mutexMax,
    int mutexTasSpins,
    long regionNowait,
    long regionWait,
    long regmax,
    long regSize)
  {
    this();
    this.mutexAlign = mutexAlign;
    setMutexAlignIsSet(true);
    this.mutexCount = mutexCount;
    setMutexCountIsSet(true);
    this.mutexFree = mutexFree;
    setMutexFreeIsSet(true);
    this.mutexInit = mutexInit;
    setMutexInitIsSet(true);
    this.mutexInuse = mutexInuse;
    setMutexInuseIsSet(true);
    this.mutexInuseMax = mutexInuseMax;
    setMutexInuseMaxIsSet(true);
    this.mutexMax = mutexMax;
    setMutexMaxIsSet(true);
    this.mutexTasSpins = mutexTasSpins;
    setMutexTasSpinsIsSet(true);
    this.regionNowait = regionNowait;
    setRegionNowaitIsSet(true);
    this.regionWait = regionWait;
    setRegionWaitIsSet(true);
    this.regmax = regmax;
    setRegmaxIsSet(true);
    this.regSize = regSize;
    setRegSizeIsSet(true);
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public TMutexStat(TMutexStat other) {
    __isset_bitfield = other.__isset_bitfield;
    this.mutexAlign = other.mutexAlign;
    this.mutexCount = other.mutexCount;
    this.mutexFree = other.mutexFree;
    this.mutexInit = other.mutexInit;
    this.mutexInuse = other.mutexInuse;
    this.mutexInuseMax = other.mutexInuseMax;
    this.mutexMax = other.mutexMax;
    this.mutexTasSpins = other.mutexTasSpins;
    this.regionNowait = other.regionNowait;
    this.regionWait = other.regionWait;
    this.regmax = other.regmax;
    this.regSize = other.regSize;
  }

  public TMutexStat deepCopy() {
    return new TMutexStat(this);
  }

  @Override
  public void clear() {
    setMutexAlignIsSet(false);
    this.mutexAlign = 0;
    setMutexCountIsSet(false);
    this.mutexCount = 0;
    setMutexFreeIsSet(false);
    this.mutexFree = 0;
    setMutexInitIsSet(false);
    this.mutexInit = 0;
    setMutexInuseIsSet(false);
    this.mutexInuse = 0;
    setMutexInuseMaxIsSet(false);
    this.mutexInuseMax = 0;
    setMutexMaxIsSet(false);
    this.mutexMax = 0;
    setMutexTasSpinsIsSet(false);
    this.mutexTasSpins = 0;
    setRegionNowaitIsSet(false);
    this.regionNowait = 0;
    setRegionWaitIsSet(false);
    this.regionWait = 0;
    setRegmaxIsSet(false);
    this.regmax = 0;
    setRegSizeIsSet(false);
    this.regSize = 0;
  }

  public int getMutexAlign() {
    return this.mutexAlign;
  }

  public TMutexStat setMutexAlign(int mutexAlign) {
    this.mutexAlign = mutexAlign;
    setMutexAlignIsSet(true);
    return this;
  }

  public void unsetMutexAlign() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MUTEXALIGN_ISSET_ID);
  }

  /** Returns true if field mutexAlign is set (has been assigned a value) and false otherwise */
  public boolean isSetMutexAlign() {
    return EncodingUtils.testBit(__isset_bitfield, __MUTEXALIGN_ISSET_ID);
  }

  public void setMutexAlignIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MUTEXALIGN_ISSET_ID, value);
  }

  public int getMutexCount() {
    return this.mutexCount;
  }

  public TMutexStat setMutexCount(int mutexCount) {
    this.mutexCount = mutexCount;
    setMutexCountIsSet(true);
    return this;
  }

  public void unsetMutexCount() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MUTEXCOUNT_ISSET_ID);
  }

  /** Returns true if field mutexCount is set (has been assigned a value) and false otherwise */
  public boolean isSetMutexCount() {
    return EncodingUtils.testBit(__isset_bitfield, __MUTEXCOUNT_ISSET_ID);
  }

  public void setMutexCountIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MUTEXCOUNT_ISSET_ID, value);
  }

  public int getMutexFree() {
    return this.mutexFree;
  }

  public TMutexStat setMutexFree(int mutexFree) {
    this.mutexFree = mutexFree;
    setMutexFreeIsSet(true);
    return this;
  }

  public void unsetMutexFree() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MUTEXFREE_ISSET_ID);
  }

  /** Returns true if field mutexFree is set (has been assigned a value) and false otherwise */
  public boolean isSetMutexFree() {
    return EncodingUtils.testBit(__isset_bitfield, __MUTEXFREE_ISSET_ID);
  }

  public void setMutexFreeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MUTEXFREE_ISSET_ID, value);
  }

  public int getMutexInit() {
    return this.mutexInit;
  }

  public TMutexStat setMutexInit(int mutexInit) {
    this.mutexInit = mutexInit;
    setMutexInitIsSet(true);
    return this;
  }

  public void unsetMutexInit() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MUTEXINIT_ISSET_ID);
  }

  /** Returns true if field mutexInit is set (has been assigned a value) and false otherwise */
  public boolean isSetMutexInit() {
    return EncodingUtils.testBit(__isset_bitfield, __MUTEXINIT_ISSET_ID);
  }

  public void setMutexInitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MUTEXINIT_ISSET_ID, value);
  }

  public int getMutexInuse() {
    return this.mutexInuse;
  }

  public TMutexStat setMutexInuse(int mutexInuse) {
    this.mutexInuse = mutexInuse;
    setMutexInuseIsSet(true);
    return this;
  }

  public void unsetMutexInuse() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MUTEXINUSE_ISSET_ID);
  }

  /** Returns true if field mutexInuse is set (has been assigned a value) and false otherwise */
  public boolean isSetMutexInuse() {
    return EncodingUtils.testBit(__isset_bitfield, __MUTEXINUSE_ISSET_ID);
  }

  public void setMutexInuseIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MUTEXINUSE_ISSET_ID, value);
  }

  public int getMutexInuseMax() {
    return this.mutexInuseMax;
  }

  public TMutexStat setMutexInuseMax(int mutexInuseMax) {
    this.mutexInuseMax = mutexInuseMax;
    setMutexInuseMaxIsSet(true);
    return this;
  }

  public void unsetMutexInuseMax() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MUTEXINUSEMAX_ISSET_ID);
  }

  /** Returns true if field mutexInuseMax is set (has been assigned a value) and false otherwise */
  public boolean isSetMutexInuseMax() {
    return EncodingUtils.testBit(__isset_bitfield, __MUTEXINUSEMAX_ISSET_ID);
  }

  public void setMutexInuseMaxIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MUTEXINUSEMAX_ISSET_ID, value);
  }

  public int getMutexMax() {
    return this.mutexMax;
  }

  public TMutexStat setMutexMax(int mutexMax) {
    this.mutexMax = mutexMax;
    setMutexMaxIsSet(true);
    return this;
  }

  public void unsetMutexMax() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MUTEXMAX_ISSET_ID);
  }

  /** Returns true if field mutexMax is set (has been assigned a value) and false otherwise */
  public boolean isSetMutexMax() {
    return EncodingUtils.testBit(__isset_bitfield, __MUTEXMAX_ISSET_ID);
  }

  public void setMutexMaxIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MUTEXMAX_ISSET_ID, value);
  }

  public int getMutexTasSpins() {
    return this.mutexTasSpins;
  }

  public TMutexStat setMutexTasSpins(int mutexTasSpins) {
    this.mutexTasSpins = mutexTasSpins;
    setMutexTasSpinsIsSet(true);
    return this;
  }

  public void unsetMutexTasSpins() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MUTEXTASSPINS_ISSET_ID);
  }

  /** Returns true if field mutexTasSpins is set (has been assigned a value) and false otherwise */
  public boolean isSetMutexTasSpins() {
    return EncodingUtils.testBit(__isset_bitfield, __MUTEXTASSPINS_ISSET_ID);
  }

  public void setMutexTasSpinsIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MUTEXTASSPINS_ISSET_ID, value);
  }

  public long getRegionNowait() {
    return this.regionNowait;
  }

  public TMutexStat setRegionNowait(long regionNowait) {
    this.regionNowait = regionNowait;
    setRegionNowaitIsSet(true);
    return this;
  }

  public void unsetRegionNowait() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __REGIONNOWAIT_ISSET_ID);
  }

  /** Returns true if field regionNowait is set (has been assigned a value) and false otherwise */
  public boolean isSetRegionNowait() {
    return EncodingUtils.testBit(__isset_bitfield, __REGIONNOWAIT_ISSET_ID);
  }

  public void setRegionNowaitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __REGIONNOWAIT_ISSET_ID, value);
  }

  public long getRegionWait() {
    return this.regionWait;
  }

  public TMutexStat setRegionWait(long regionWait) {
    this.regionWait = regionWait;
    setRegionWaitIsSet(true);
    return this;
  }

  public void unsetRegionWait() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __REGIONWAIT_ISSET_ID);
  }

  /** Returns true if field regionWait is set (has been assigned a value) and false otherwise */
  public boolean isSetRegionWait() {
    return EncodingUtils.testBit(__isset_bitfield, __REGIONWAIT_ISSET_ID);
  }

  public void setRegionWaitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __REGIONWAIT_ISSET_ID, value);
  }

  public long getRegmax() {
    return this.regmax;
  }

  public TMutexStat setRegmax(long regmax) {
    this.regmax = regmax;
    setRegmaxIsSet(true);
    return this;
  }

  public void unsetRegmax() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __REGMAX_ISSET_ID);
  }

  /** Returns true if field regmax is set (has been assigned a value) and false otherwise */
  public boolean isSetRegmax() {
    return EncodingUtils.testBit(__isset_bitfield, __REGMAX_ISSET_ID);
  }

  public void setRegmaxIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __REGMAX_ISSET_ID, value);
  }

  public long getRegSize() {
    return this.regSize;
  }

  public TMutexStat setRegSize(long regSize) {
    this.regSize = regSize;
    setRegSizeIsSet(true);
    return this;
  }

  public void unsetRegSize() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __REGSIZE_ISSET_ID);
  }

  /** Returns true if field regSize is set (has been assigned a value) and false otherwise */
  public boolean isSetRegSize() {
    return EncodingUtils.testBit(__isset_bitfield, __REGSIZE_ISSET_ID);
  }

  public void setRegSizeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __REGSIZE_ISSET_ID, value);
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case MUTEX_ALIGN:
      if (value == null) {
        unsetMutexAlign();
      } else {
        setMutexAlign((Integer)value);
      }
      break;

    case MUTEX_COUNT:
      if (value == null) {
        unsetMutexCount();
      } else {
        setMutexCount((Integer)value);
      }
      break;

    case MUTEX_FREE:
      if (value == null) {
        unsetMutexFree();
      } else {
        setMutexFree((Integer)value);
      }
      break;

    case MUTEX_INIT:
      if (value == null) {
        unsetMutexInit();
      } else {
        setMutexInit((Integer)value);
      }
      break;

    case MUTEX_INUSE:
      if (value == null) {
        unsetMutexInuse();
      } else {
        setMutexInuse((Integer)value);
      }
      break;

    case MUTEX_INUSE_MAX:
      if (value == null) {
        unsetMutexInuseMax();
      } else {
        setMutexInuseMax((Integer)value);
      }
      break;

    case MUTEX_MAX:
      if (value == null) {
        unsetMutexMax();
      } else {
        setMutexMax((Integer)value);
      }
      break;

    case MUTEX_TAS_SPINS:
      if (value == null) {
        unsetMutexTasSpins();
      } else {
        setMutexTasSpins((Integer)value);
      }
      break;

    case REGION_NOWAIT:
      if (value == null) {
        unsetRegionNowait();
      } else {
        setRegionNowait((Long)value);
      }
      break;

    case REGION_WAIT:
      if (value == null) {
        unsetRegionWait();
      } else {
        setRegionWait((Long)value);
      }
      break;

    case REGMAX:
      if (value == null) {
        unsetRegmax();
      } else {
        setRegmax((Long)value);
      }
      break;

    case REG_SIZE:
      if (value == null) {
        unsetRegSize();
      } else {
        setRegSize((Long)value);
      }
      break;

    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case MUTEX_ALIGN:
      return Integer.valueOf(getMutexAlign());

    case MUTEX_COUNT:
      return Integer.valueOf(getMutexCount());

    case MUTEX_FREE:
      return Integer.valueOf(getMutexFree());

    case MUTEX_INIT:
      return Integer.valueOf(getMutexInit());

    case MUTEX_INUSE:
      return Integer.valueOf(getMutexInuse());

    case MUTEX_INUSE_MAX:
      return Integer.valueOf(getMutexInuseMax());

    case MUTEX_MAX:
      return Integer.valueOf(getMutexMax());

    case MUTEX_TAS_SPINS:
      return Integer.valueOf(getMutexTasSpins());

    case REGION_NOWAIT:
      return Long.valueOf(getRegionNowait());

    case REGION_WAIT:
      return Long.valueOf(getRegionWait());

    case REGMAX:
      return Long.valueOf(getRegmax());

    case REG_SIZE:
      return Long.valueOf(getRegSize());

    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case MUTEX_ALIGN:
      return isSetMutexAlign();
    case MUTEX_COUNT:
      return isSetMutexCount();
    case MUTEX_FREE:
      return isSetMutexFree();
    case MUTEX_INIT:
      return isSetMutexInit();
    case MUTEX_INUSE:
      return isSetMutexInuse();
    case MUTEX_INUSE_MAX:
      return isSetMutexInuseMax();
    case MUTEX_MAX:
      return isSetMutexMax();
    case MUTEX_TAS_SPINS:
      return isSetMutexTasSpins();
    case REGION_NOWAIT:
      return isSetRegionNowait();
    case REGION_WAIT:
      return isSetRegionWait();
    case REGMAX:
      return isSetRegmax();
    case REG_SIZE:
      return isSetRegSize();
    }
    throw new IllegalStateException();
  }

  @Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof TMutexStat)
      return this.equals((TMutexStat)that);
    return false;
  }

  public boolean equals(TMutexStat that) {
    if (that == null)
      return false;

    boolean this_present_mutexAlign = true;
    boolean that_present_mutexAlign = true;
    if (this_present_mutexAlign || that_present_mutexAlign) {
      if (!(this_present_mutexAlign && that_present_mutexAlign))
        return false;
      if (this.mutexAlign != that.mutexAlign)
        return false;
    }

    boolean this_present_mutexCount = true;
    boolean that_present_mutexCount = true;
    if (this_present_mutexCount || that_present_mutexCount) {
      if (!(this_present_mutexCount && that_present_mutexCount))
        return false;
      if (this.mutexCount != that.mutexCount)
        return false;
    }

    boolean this_present_mutexFree = true;
    boolean that_present_mutexFree = true;
    if (this_present_mutexFree || that_present_mutexFree) {
      if (!(this_present_mutexFree && that_present_mutexFree))
        return false;
      if (this.mutexFree != that.mutexFree)
        return false;
    }

    boolean this_present_mutexInit = true;
    boolean that_present_mutexInit = true;
    if (this_present_mutexInit || that_present_mutexInit) {
      if (!(this_present_mutexInit && that_present_mutexInit))
        return false;
      if (this.mutexInit != that.mutexInit)
        return false;
    }

    boolean this_present_mutexInuse = true;
    boolean that_present_mutexInuse = true;
    if (this_present_mutexInuse || that_present_mutexInuse) {
      if (!(this_present_mutexInuse && that_present_mutexInuse))
        return false;
      if (this.mutexInuse != that.mutexInuse)
        return false;
    }

    boolean this_present_mutexInuseMax = true;
    boolean that_present_mutexInuseMax = true;
    if (this_present_mutexInuseMax || that_present_mutexInuseMax) {
      if (!(this_present_mutexInuseMax && that_present_mutexInuseMax))
        return false;
      if (this.mutexInuseMax != that.mutexInuseMax)
        return false;
    }

    boolean this_present_mutexMax = true;
    boolean that_present_mutexMax = true;
    if (this_present_mutexMax || that_present_mutexMax) {
      if (!(this_present_mutexMax && that_present_mutexMax))
        return false;
      if (this.mutexMax != that.mutexMax)
        return false;
    }

    boolean this_present_mutexTasSpins = true;
    boolean that_present_mutexTasSpins = true;
    if (this_present_mutexTasSpins || that_present_mutexTasSpins) {
      if (!(this_present_mutexTasSpins && that_present_mutexTasSpins))
        return false;
      if (this.mutexTasSpins != that.mutexTasSpins)
        return false;
    }

    boolean this_present_regionNowait = true;
    boolean that_present_regionNowait = true;
    if (this_present_regionNowait || that_present_regionNowait) {
      if (!(this_present_regionNowait && that_present_regionNowait))
        return false;
      if (this.regionNowait != that.regionNowait)
        return false;
    }

    boolean this_present_regionWait = true;
    boolean that_present_regionWait = true;
    if (this_present_regionWait || that_present_regionWait) {
      if (!(this_present_regionWait && that_present_regionWait))
        return false;
      if (this.regionWait != that.regionWait)
        return false;
    }

    boolean this_present_regmax = true;
    boolean that_present_regmax = true;
    if (this_present_regmax || that_present_regmax) {
      if (!(this_present_regmax && that_present_regmax))
        return false;
      if (this.regmax != that.regmax)
        return false;
    }

    boolean this_present_regSize = true;
    boolean that_present_regSize = true;
    if (this_present_regSize || that_present_regSize) {
      if (!(this_present_regSize && that_present_regSize))
        return false;
      if (this.regSize != that.regSize)
        return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    List<Object> list = new ArrayList<Object>();

    boolean present_mutexAlign = true;
    list.add(present_mutexAlign);
    if (present_mutexAlign)
      list.add(mutexAlign);

    boolean present_mutexCount = true;
    list.add(present_mutexCount);
    if (present_mutexCount)
      list.add(mutexCount);

    boolean present_mutexFree = true;
    list.add(present_mutexFree);
    if (present_mutexFree)
      list.add(mutexFree);

    boolean present_mutexInit = true;
    list.add(present_mutexInit);
    if (present_mutexInit)
      list.add(mutexInit);

    boolean present_mutexInuse = true;
    list.add(present_mutexInuse);
    if (present_mutexInuse)
      list.add(mutexInuse);

    boolean present_mutexInuseMax = true;
    list.add(present_mutexInuseMax);
    if (present_mutexInuseMax)
      list.add(mutexInuseMax);

    boolean present_mutexMax = true;
    list.add(present_mutexMax);
    if (present_mutexMax)
      list.add(mutexMax);

    boolean present_mutexTasSpins = true;
    list.add(present_mutexTasSpins);
    if (present_mutexTasSpins)
      list.add(mutexTasSpins);

    boolean present_regionNowait = true;
    list.add(present_regionNowait);
    if (present_regionNowait)
      list.add(regionNowait);

    boolean present_regionWait = true;
    list.add(present_regionWait);
    if (present_regionWait)
      list.add(regionWait);

    boolean present_regmax = true;
    list.add(present_regmax);
    if (present_regmax)
      list.add(regmax);

    boolean present_regSize = true;
    list.add(present_regSize);
    if (present_regSize)
      list.add(regSize);

    return list.hashCode();
  }

  @Override
  public int compareTo(TMutexStat other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;

    lastComparison = Boolean.valueOf(isSetMutexAlign()).compareTo(other.isSetMutexAlign());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMutexAlign()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.mutexAlign, other.mutexAlign);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMutexCount()).compareTo(other.isSetMutexCount());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMutexCount()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.mutexCount, other.mutexCount);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMutexFree()).compareTo(other.isSetMutexFree());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMutexFree()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.mutexFree, other.mutexFree);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMutexInit()).compareTo(other.isSetMutexInit());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMutexInit()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.mutexInit, other.mutexInit);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMutexInuse()).compareTo(other.isSetMutexInuse());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMutexInuse()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.mutexInuse, other.mutexInuse);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMutexInuseMax()).compareTo(other.isSetMutexInuseMax());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMutexInuseMax()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.mutexInuseMax, other.mutexInuseMax);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMutexMax()).compareTo(other.isSetMutexMax());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMutexMax()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.mutexMax, other.mutexMax);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMutexTasSpins()).compareTo(other.isSetMutexTasSpins());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMutexTasSpins()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.mutexTasSpins, other.mutexTasSpins);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRegionNowait()).compareTo(other.isSetRegionNowait());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRegionNowait()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.regionNowait, other.regionNowait);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRegionWait()).compareTo(other.isSetRegionWait());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRegionWait()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.regionWait, other.regionWait);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRegmax()).compareTo(other.isSetRegmax());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRegmax()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.regmax, other.regmax);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRegSize()).compareTo(other.isSetRegSize());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRegSize()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.regSize, other.regSize);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }

  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
  }

  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("TMutexStat(");
    boolean first = true;

    sb.append("mutexAlign:");
    sb.append(this.mutexAlign);
    first = false;
    if (!first) sb.append(", ");
    sb.append("mutexCount:");
    sb.append(this.mutexCount);
    first = false;
    if (!first) sb.append(", ");
    sb.append("mutexFree:");
    sb.append(this.mutexFree);
    first = false;
    if (!first) sb.append(", ");
    sb.append("mutexInit:");
    sb.append(this.mutexInit);
    first = false;
    if (!first) sb.append(", ");
    sb.append("mutexInuse:");
    sb.append(this.mutexInuse);
    first = false;
    if (!first) sb.append(", ");
    sb.append("mutexInuseMax:");
    sb.append(this.mutexInuseMax);
    first = false;
    if (!first) sb.append(", ");
    sb.append("mutexMax:");
    sb.append(this.mutexMax);
    first = false;
    if (!first) sb.append(", ");
    sb.append("mutexTasSpins:");
    sb.append(this.mutexTasSpins);
    first = false;
    if (!first) sb.append(", ");
    sb.append("regionNowait:");
    sb.append(this.regionNowait);
    first = false;
    if (!first) sb.append(", ");
    sb.append("regionWait:");
    sb.append(this.regionWait);
    first = false;
    if (!first) sb.append(", ");
    sb.append("regmax:");
    sb.append(this.regmax);
    first = false;
    if (!first) sb.append(", ");
    sb.append("regSize:");
    sb.append(this.regSize);
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws org.apache.thrift.TException {
    // check for required fields
    // check for sub-struct validity
  }

  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
    try {
      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
    try {
      // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
      __isset_bitfield = 0;
      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private static class TMutexStatStandardSchemeFactory implements SchemeFactory {
    public TMutexStatStandardScheme getScheme() {
      return new TMutexStatStandardScheme();
    }
  }

  private static class TMutexStatStandardScheme extends StandardScheme<TMutexStat> {

    public void read(org.apache.thrift.protocol.TProtocol iprot, TMutexStat struct) throws org.apache.thrift.TException {
      org.apache.thrift.protocol.TField schemeField;
      iprot.readStructBegin();
      while (true)
      {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (schemeField.id) {
          case 1: // MUTEX_ALIGN
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.mutexAlign = iprot.readI32();
              struct.setMutexAlignIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 2: // MUTEX_COUNT
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.mutexCount = iprot.readI32();
              struct.setMutexCountIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 3: // MUTEX_FREE
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.mutexFree = iprot.readI32();
              struct.setMutexFreeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 4: // MUTEX_INIT
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.mutexInit = iprot.readI32();
              struct.setMutexInitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 5: // MUTEX_INUSE
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.mutexInuse = iprot.readI32();
              struct.setMutexInuseIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 6: // MUTEX_INUSE_MAX
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.mutexInuseMax = iprot.readI32();
              struct.setMutexInuseMaxIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 7: // MUTEX_MAX
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.mutexMax = iprot.readI32();
              struct.setMutexMaxIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 8: // MUTEX_TAS_SPINS
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.mutexTasSpins = iprot.readI32();
              struct.setMutexTasSpinsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 9: // REGION_NOWAIT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.regionNowait = iprot.readI64();
              struct.setRegionNowaitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 10: // REGION_WAIT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.regionWait = iprot.readI64();
              struct.setRegionWaitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 11: // REGMAX
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.regmax = iprot.readI64();
              struct.setRegmaxIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 12: // REG_SIZE
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.regSize = iprot.readI64();
              struct.setRegSizeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      struct.validate();
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot, TMutexStat struct) throws org.apache.thrift.TException {
      struct.validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(MUTEX_ALIGN_FIELD_DESC);
      oprot.writeI32(struct.mutexAlign);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MUTEX_COUNT_FIELD_DESC);
      oprot.writeI32(struct.mutexCount);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MUTEX_FREE_FIELD_DESC);
      oprot.writeI32(struct.mutexFree);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MUTEX_INIT_FIELD_DESC);
      oprot.writeI32(struct.mutexInit);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MUTEX_INUSE_FIELD_DESC);
      oprot.writeI32(struct.mutexInuse);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MUTEX_INUSE_MAX_FIELD_DESC);
      oprot.writeI32(struct.mutexInuseMax);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MUTEX_MAX_FIELD_DESC);
      oprot.writeI32(struct.mutexMax);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MUTEX_TAS_SPINS_FIELD_DESC);
      oprot.writeI32(struct.mutexTasSpins);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(REGION_NOWAIT_FIELD_DESC);
      oprot.writeI64(struct.regionNowait);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(REGION_WAIT_FIELD_DESC);
      oprot.writeI64(struct.regionWait);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(REGMAX_FIELD_DESC);
      oprot.writeI64(struct.regmax);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(REG_SIZE_FIELD_DESC);
      oprot.writeI64(struct.regSize);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

  }

  private static class TMutexStatTupleSchemeFactory implements SchemeFactory {
    public TMutexStatTupleScheme getScheme() {
      return new TMutexStatTupleScheme();
    }
  }

  private static class TMutexStatTupleScheme extends TupleScheme<TMutexStat> {

    @Override
    public void write(org.apache.thrift.protocol.TProtocol prot, TMutexStat struct) throws org.apache.thrift.TException {
      TTupleProtocol oprot = (TTupleProtocol) prot;
      BitSet optionals = new BitSet();
      if (struct.isSetMutexAlign()) {
        optionals.set(0);
      }
      if (struct.isSetMutexCount()) {
        optionals.set(1);
      }
      if (struct.isSetMutexFree()) {
        optionals.set(2);
      }
      if (struct.isSetMutexInit()) {
        optionals.set(3);
      }
      if (struct.isSetMutexInuse()) {
        optionals.set(4);
      }
      if (struct.isSetMutexInuseMax()) {
        optionals.set(5);
      }
      if (struct.isSetMutexMax()) {
        optionals.set(6);
      }
      if (struct.isSetMutexTasSpins()) {
        optionals.set(7);
      }
      if (struct.isSetRegionNowait()) {
        optionals.set(8);
      }
      if (struct.isSetRegionWait()) {
        optionals.set(9);
      }
      if (struct.isSetRegmax()) {
        optionals.set(10);
      }
      if (struct.isSetRegSize()) {
        optionals.set(11);
      }
      oprot.writeBitSet(optionals, 12);
      if (struct.isSetMutexAlign()) {
        oprot.writeI32(struct.mutexAlign);
      }
      if (struct.isSetMutexCount()) {
        oprot.writeI32(struct.mutexCount);
      }
      if (struct.isSetMutexFree()) {
        oprot.writeI32(struct.mutexFree);
      }
      if (struct.isSetMutexInit()) {
        oprot.writeI32(struct.mutexInit);
      }
      if (struct.isSetMutexInuse()) {
        oprot.writeI32(struct.mutexInuse);
      }
      if (struct.isSetMutexInuseMax()) {
        oprot.writeI32(struct.mutexInuseMax);
      }
      if (struct.isSetMutexMax()) {
        oprot.writeI32(struct.mutexMax);
      }
      if (struct.isSetMutexTasSpins()) {
        oprot.writeI32(struct.mutexTasSpins);
      }
      if (struct.isSetRegionNowait()) {
        oprot.writeI64(struct.regionNowait);
      }
      if (struct.isSetRegionWait()) {
        oprot.writeI64(struct.regionWait);
      }
      if (struct.isSetRegmax()) {
        oprot.writeI64(struct.regmax);
      }
      if (struct.isSetRegSize()) {
        oprot.writeI64(struct.regSize);
      }
    }

    @Override
    public void read(org.apache.thrift.protocol.TProtocol prot, TMutexStat struct) throws org.apache.thrift.TException {
      TTupleProtocol iprot = (TTupleProtocol) prot;
      BitSet incoming = iprot.readBitSet(12);
      if (incoming.get(0)) {
        struct.mutexAlign = iprot.readI32();
        struct.setMutexAlignIsSet(true);
      }
      if (incoming.get(1)) {
        struct.mutexCount = iprot.readI32();
        struct.setMutexCountIsSet(true);
      }
      if (incoming.get(2)) {
        struct.mutexFree = iprot.readI32();
        struct.setMutexFreeIsSet(true);
      }
      if (incoming.get(3)) {
        struct.mutexInit = iprot.readI32();
        struct.setMutexInitIsSet(true);
      }
      if (incoming.get(4)) {
        struct.mutexInuse = iprot.readI32();
        struct.setMutexInuseIsSet(true);
      }
      if (incoming.get(5)) {
        struct.mutexInuseMax = iprot.readI32();
        struct.setMutexInuseMaxIsSet(true);
      }
      if (incoming.get(6)) {
        struct.mutexMax = iprot.readI32();
        struct.setMutexMaxIsSet(true);
      }
      if (incoming.get(7)) {
        struct.mutexTasSpins = iprot.readI32();
        struct.setMutexTasSpinsIsSet(true);
      }
      if (incoming.get(8)) {
        struct.regionNowait = iprot.readI64();
        struct.setRegionNowaitIsSet(true);
      }
      if (incoming.get(9)) {
        struct.regionWait = iprot.readI64();
        struct.setRegionWaitIsSet(true);
      }
      if (incoming.get(10)) {
        struct.regmax = iprot.readI64();
        struct.setRegmaxIsSet(true);
      }
      if (incoming.get(11)) {
        struct.regSize = iprot.readI64();
        struct.setRegSizeIsSet(true);
      }
    }
  }

}

