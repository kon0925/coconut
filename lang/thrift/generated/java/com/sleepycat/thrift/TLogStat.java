/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.sleepycat.thrift;

import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import org.apache.thrift.async.AsyncMethodCallback;
import org.apache.thrift.server.AbstractNonblockingServer.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import javax.annotation.Generated;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
@Generated(value = "Autogenerated by Thrift Compiler (0.9.2)", date = "2015-10-9")
public class TLogStat implements org.apache.thrift.TBase<TLogStat, TLogStat._Fields>, java.io.Serializable, Cloneable, Comparable<TLogStat> {
  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("TLogStat");

  private static final org.apache.thrift.protocol.TField CUR_FILE_FIELD_DESC = new org.apache.thrift.protocol.TField("curFile", org.apache.thrift.protocol.TType.I32, (short)1);
  private static final org.apache.thrift.protocol.TField CUR_OFFSET_FIELD_DESC = new org.apache.thrift.protocol.TField("curOffset", org.apache.thrift.protocol.TType.I32, (short)2);
  private static final org.apache.thrift.protocol.TField DISK_FILE_FIELD_DESC = new org.apache.thrift.protocol.TField("diskFile", org.apache.thrift.protocol.TType.I32, (short)3);
  private static final org.apache.thrift.protocol.TField DISK_OFFSET_FIELD_DESC = new org.apache.thrift.protocol.TField("diskOffset", org.apache.thrift.protocol.TType.I32, (short)4);
  private static final org.apache.thrift.protocol.TField FILEID_INIT_FIELD_DESC = new org.apache.thrift.protocol.TField("fileidInit", org.apache.thrift.protocol.TType.I32, (short)5);
  private static final org.apache.thrift.protocol.TField LG_BSIZE_FIELD_DESC = new org.apache.thrift.protocol.TField("lgBSize", org.apache.thrift.protocol.TType.I32, (short)6);
  private static final org.apache.thrift.protocol.TField LG_SIZE_FIELD_DESC = new org.apache.thrift.protocol.TField("lgSize", org.apache.thrift.protocol.TType.I32, (short)7);
  private static final org.apache.thrift.protocol.TField MAGIC_FIELD_DESC = new org.apache.thrift.protocol.TField("magic", org.apache.thrift.protocol.TType.I32, (short)8);
  private static final org.apache.thrift.protocol.TField MAX_COMMITPERFLUSH_FIELD_DESC = new org.apache.thrift.protocol.TField("maxCommitperflush", org.apache.thrift.protocol.TType.I32, (short)9);
  private static final org.apache.thrift.protocol.TField MAX_NFILE_ID_FIELD_DESC = new org.apache.thrift.protocol.TField("maxNfileId", org.apache.thrift.protocol.TType.I32, (short)10);
  private static final org.apache.thrift.protocol.TField MIN_COMMITPERFLUSH_FIELD_DESC = new org.apache.thrift.protocol.TField("minCommitperflush", org.apache.thrift.protocol.TType.I32, (short)11);
  private static final org.apache.thrift.protocol.TField MODE_FIELD_DESC = new org.apache.thrift.protocol.TField("mode", org.apache.thrift.protocol.TType.I32, (short)12);
  private static final org.apache.thrift.protocol.TField NUM_FILE_ID_FIELD_DESC = new org.apache.thrift.protocol.TField("numFileId", org.apache.thrift.protocol.TType.I32, (short)13);
  private static final org.apache.thrift.protocol.TField RCOUNT_FIELD_DESC = new org.apache.thrift.protocol.TField("RCount", org.apache.thrift.protocol.TType.I64, (short)14);
  private static final org.apache.thrift.protocol.TField RECORD_FIELD_DESC = new org.apache.thrift.protocol.TField("record", org.apache.thrift.protocol.TType.I64, (short)15);
  private static final org.apache.thrift.protocol.TField REGION_NOWAIT_FIELD_DESC = new org.apache.thrift.protocol.TField("regionNowait", org.apache.thrift.protocol.TType.I64, (short)16);
  private static final org.apache.thrift.protocol.TField REGION_WAIT_FIELD_DESC = new org.apache.thrift.protocol.TField("regionWait", org.apache.thrift.protocol.TType.I64, (short)17);
  private static final org.apache.thrift.protocol.TField REG_SIZE_FIELD_DESC = new org.apache.thrift.protocol.TField("regSize", org.apache.thrift.protocol.TType.I64, (short)18);
  private static final org.apache.thrift.protocol.TField SCOUNT_FIELD_DESC = new org.apache.thrift.protocol.TField("SCount", org.apache.thrift.protocol.TType.I64, (short)19);
  private static final org.apache.thrift.protocol.TField VERSION_FIELD_DESC = new org.apache.thrift.protocol.TField("version", org.apache.thrift.protocol.TType.I32, (short)20);
  private static final org.apache.thrift.protocol.TField WBYTES_FIELD_DESC = new org.apache.thrift.protocol.TField("WBytes", org.apache.thrift.protocol.TType.I32, (short)21);
  private static final org.apache.thrift.protocol.TField WC_BYTES_FIELD_DESC = new org.apache.thrift.protocol.TField("wcBytes", org.apache.thrift.protocol.TType.I32, (short)22);
  private static final org.apache.thrift.protocol.TField WC_MBYTES_FIELD_DESC = new org.apache.thrift.protocol.TField("wcMbytes", org.apache.thrift.protocol.TType.I32, (short)23);
  private static final org.apache.thrift.protocol.TField WMBYTES_FIELD_DESC = new org.apache.thrift.protocol.TField("WMbytes", org.apache.thrift.protocol.TType.I32, (short)24);
  private static final org.apache.thrift.protocol.TField WCOUNT_FIELD_DESC = new org.apache.thrift.protocol.TField("WCount", org.apache.thrift.protocol.TType.I64, (short)25);
  private static final org.apache.thrift.protocol.TField WCOUNT_FILL_FIELD_DESC = new org.apache.thrift.protocol.TField("WCountFill", org.apache.thrift.protocol.TType.I64, (short)26);

  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
  static {
    schemes.put(StandardScheme.class, new TLogStatStandardSchemeFactory());
    schemes.put(TupleScheme.class, new TLogStatTupleSchemeFactory());
  }

  public int curFile; // required
  public int curOffset; // required
  public int diskFile; // required
  public int diskOffset; // required
  public int fileidInit; // required
  public int lgBSize; // required
  public int lgSize; // required
  public int magic; // required
  public int maxCommitperflush; // required
  public int maxNfileId; // required
  public int minCommitperflush; // required
  public int mode; // required
  public int numFileId; // required
  public long RCount; // required
  public long record; // required
  public long regionNowait; // required
  public long regionWait; // required
  public long regSize; // required
  public long SCount; // required
  public int version; // required
  public int WBytes; // required
  public int wcBytes; // required
  public int wcMbytes; // required
  public int WMbytes; // required
  public long WCount; // required
  public long WCountFill; // required

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
    CUR_FILE((short)1, "curFile"),
    CUR_OFFSET((short)2, "curOffset"),
    DISK_FILE((short)3, "diskFile"),
    DISK_OFFSET((short)4, "diskOffset"),
    FILEID_INIT((short)5, "fileidInit"),
    LG_BSIZE((short)6, "lgBSize"),
    LG_SIZE((short)7, "lgSize"),
    MAGIC((short)8, "magic"),
    MAX_COMMITPERFLUSH((short)9, "maxCommitperflush"),
    MAX_NFILE_ID((short)10, "maxNfileId"),
    MIN_COMMITPERFLUSH((short)11, "minCommitperflush"),
    MODE((short)12, "mode"),
    NUM_FILE_ID((short)13, "numFileId"),
    RCOUNT((short)14, "RCount"),
    RECORD((short)15, "record"),
    REGION_NOWAIT((short)16, "regionNowait"),
    REGION_WAIT((short)17, "regionWait"),
    REG_SIZE((short)18, "regSize"),
    SCOUNT((short)19, "SCount"),
    VERSION((short)20, "version"),
    WBYTES((short)21, "WBytes"),
    WC_BYTES((short)22, "wcBytes"),
    WC_MBYTES((short)23, "wcMbytes"),
    WMBYTES((short)24, "WMbytes"),
    WCOUNT((short)25, "WCount"),
    WCOUNT_FILL((short)26, "WCountFill");

    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // CUR_FILE
          return CUR_FILE;
        case 2: // CUR_OFFSET
          return CUR_OFFSET;
        case 3: // DISK_FILE
          return DISK_FILE;
        case 4: // DISK_OFFSET
          return DISK_OFFSET;
        case 5: // FILEID_INIT
          return FILEID_INIT;
        case 6: // LG_BSIZE
          return LG_BSIZE;
        case 7: // LG_SIZE
          return LG_SIZE;
        case 8: // MAGIC
          return MAGIC;
        case 9: // MAX_COMMITPERFLUSH
          return MAX_COMMITPERFLUSH;
        case 10: // MAX_NFILE_ID
          return MAX_NFILE_ID;
        case 11: // MIN_COMMITPERFLUSH
          return MIN_COMMITPERFLUSH;
        case 12: // MODE
          return MODE;
        case 13: // NUM_FILE_ID
          return NUM_FILE_ID;
        case 14: // RCOUNT
          return RCOUNT;
        case 15: // RECORD
          return RECORD;
        case 16: // REGION_NOWAIT
          return REGION_NOWAIT;
        case 17: // REGION_WAIT
          return REGION_WAIT;
        case 18: // REG_SIZE
          return REG_SIZE;
        case 19: // SCOUNT
          return SCOUNT;
        case 20: // VERSION
          return VERSION;
        case 21: // WBYTES
          return WBYTES;
        case 22: // WC_BYTES
          return WC_BYTES;
        case 23: // WC_MBYTES
          return WC_MBYTES;
        case 24: // WMBYTES
          return WMBYTES;
        case 25: // WCOUNT
          return WCOUNT;
        case 26: // WCOUNT_FILL
          return WCOUNT_FILL;
        default:
          return null;
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }

    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }

    private final short _thriftId;
    private final String _fieldName;

    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }

    public short getThriftFieldId() {
      return _thriftId;
    }

    public String getFieldName() {
      return _fieldName;
    }
  }

  // isset id assignments
  private static final int __CURFILE_ISSET_ID = 0;
  private static final int __CUROFFSET_ISSET_ID = 1;
  private static final int __DISKFILE_ISSET_ID = 2;
  private static final int __DISKOFFSET_ISSET_ID = 3;
  private static final int __FILEIDINIT_ISSET_ID = 4;
  private static final int __LGBSIZE_ISSET_ID = 5;
  private static final int __LGSIZE_ISSET_ID = 6;
  private static final int __MAGIC_ISSET_ID = 7;
  private static final int __MAXCOMMITPERFLUSH_ISSET_ID = 8;
  private static final int __MAXNFILEID_ISSET_ID = 9;
  private static final int __MINCOMMITPERFLUSH_ISSET_ID = 10;
  private static final int __MODE_ISSET_ID = 11;
  private static final int __NUMFILEID_ISSET_ID = 12;
  private static final int __RCOUNT_ISSET_ID = 13;
  private static final int __RECORD_ISSET_ID = 14;
  private static final int __REGIONNOWAIT_ISSET_ID = 15;
  private static final int __REGIONWAIT_ISSET_ID = 16;
  private static final int __REGSIZE_ISSET_ID = 17;
  private static final int __SCOUNT_ISSET_ID = 18;
  private static final int __VERSION_ISSET_ID = 19;
  private static final int __WBYTES_ISSET_ID = 20;
  private static final int __WCBYTES_ISSET_ID = 21;
  private static final int __WCMBYTES_ISSET_ID = 22;
  private static final int __WMBYTES_ISSET_ID = 23;
  private static final int __WCOUNT_ISSET_ID = 24;
  private static final int __WCOUNTFILL_ISSET_ID = 25;
  private int __isset_bitfield = 0;
  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
  static {
    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.CUR_FILE, new org.apache.thrift.meta_data.FieldMetaData("curFile", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.CUR_OFFSET, new org.apache.thrift.meta_data.FieldMetaData("curOffset", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.DISK_FILE, new org.apache.thrift.meta_data.FieldMetaData("diskFile", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.DISK_OFFSET, new org.apache.thrift.meta_data.FieldMetaData("diskOffset", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.FILEID_INIT, new org.apache.thrift.meta_data.FieldMetaData("fileidInit", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.LG_BSIZE, new org.apache.thrift.meta_data.FieldMetaData("lgBSize", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.LG_SIZE, new org.apache.thrift.meta_data.FieldMetaData("lgSize", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MAGIC, new org.apache.thrift.meta_data.FieldMetaData("magic", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MAX_COMMITPERFLUSH, new org.apache.thrift.meta_data.FieldMetaData("maxCommitperflush", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MAX_NFILE_ID, new org.apache.thrift.meta_data.FieldMetaData("maxNfileId", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MIN_COMMITPERFLUSH, new org.apache.thrift.meta_data.FieldMetaData("minCommitperflush", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MODE, new org.apache.thrift.meta_data.FieldMetaData("mode", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.NUM_FILE_ID, new org.apache.thrift.meta_data.FieldMetaData("numFileId", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.RCOUNT, new org.apache.thrift.meta_data.FieldMetaData("RCount", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.RECORD, new org.apache.thrift.meta_data.FieldMetaData("record", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.REGION_NOWAIT, new org.apache.thrift.meta_data.FieldMetaData("regionNowait", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.REGION_WAIT, new org.apache.thrift.meta_data.FieldMetaData("regionWait", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.REG_SIZE, new org.apache.thrift.meta_data.FieldMetaData("regSize", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.SCOUNT, new org.apache.thrift.meta_data.FieldMetaData("SCount", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.VERSION, new org.apache.thrift.meta_data.FieldMetaData("version", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.WBYTES, new org.apache.thrift.meta_data.FieldMetaData("WBytes", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.WC_BYTES, new org.apache.thrift.meta_data.FieldMetaData("wcBytes", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.WC_MBYTES, new org.apache.thrift.meta_data.FieldMetaData("wcMbytes", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.WMBYTES, new org.apache.thrift.meta_data.FieldMetaData("WMbytes", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.WCOUNT, new org.apache.thrift.meta_data.FieldMetaData("WCount", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.WCOUNT_FILL, new org.apache.thrift.meta_data.FieldMetaData("WCountFill", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(TLogStat.class, metaDataMap);
  }

  public TLogStat() {
  }

  public TLogStat(
    int curFile,
    int curOffset,
    int diskFile,
    int diskOffset,
    int fileidInit,
    int lgBSize,
    int lgSize,
    int magic,
    int maxCommitperflush,
    int maxNfileId,
    int minCommitperflush,
    int mode,
    int numFileId,
    long RCount,
    long record,
    long regionNowait,
    long regionWait,
    long regSize,
    long SCount,
    int version,
    int WBytes,
    int wcBytes,
    int wcMbytes,
    int WMbytes,
    long WCount,
    long WCountFill)
  {
    this();
    this.curFile = curFile;
    setCurFileIsSet(true);
    this.curOffset = curOffset;
    setCurOffsetIsSet(true);
    this.diskFile = diskFile;
    setDiskFileIsSet(true);
    this.diskOffset = diskOffset;
    setDiskOffsetIsSet(true);
    this.fileidInit = fileidInit;
    setFileidInitIsSet(true);
    this.lgBSize = lgBSize;
    setLgBSizeIsSet(true);
    this.lgSize = lgSize;
    setLgSizeIsSet(true);
    this.magic = magic;
    setMagicIsSet(true);
    this.maxCommitperflush = maxCommitperflush;
    setMaxCommitperflushIsSet(true);
    this.maxNfileId = maxNfileId;
    setMaxNfileIdIsSet(true);
    this.minCommitperflush = minCommitperflush;
    setMinCommitperflushIsSet(true);
    this.mode = mode;
    setModeIsSet(true);
    this.numFileId = numFileId;
    setNumFileIdIsSet(true);
    this.RCount = RCount;
    setRCountIsSet(true);
    this.record = record;
    setRecordIsSet(true);
    this.regionNowait = regionNowait;
    setRegionNowaitIsSet(true);
    this.regionWait = regionWait;
    setRegionWaitIsSet(true);
    this.regSize = regSize;
    setRegSizeIsSet(true);
    this.SCount = SCount;
    setSCountIsSet(true);
    this.version = version;
    setVersionIsSet(true);
    this.WBytes = WBytes;
    setWBytesIsSet(true);
    this.wcBytes = wcBytes;
    setWcBytesIsSet(true);
    this.wcMbytes = wcMbytes;
    setWcMbytesIsSet(true);
    this.WMbytes = WMbytes;
    setWMbytesIsSet(true);
    this.WCount = WCount;
    setWCountIsSet(true);
    this.WCountFill = WCountFill;
    setWCountFillIsSet(true);
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public TLogStat(TLogStat other) {
    __isset_bitfield = other.__isset_bitfield;
    this.curFile = other.curFile;
    this.curOffset = other.curOffset;
    this.diskFile = other.diskFile;
    this.diskOffset = other.diskOffset;
    this.fileidInit = other.fileidInit;
    this.lgBSize = other.lgBSize;
    this.lgSize = other.lgSize;
    this.magic = other.magic;
    this.maxCommitperflush = other.maxCommitperflush;
    this.maxNfileId = other.maxNfileId;
    this.minCommitperflush = other.minCommitperflush;
    this.mode = other.mode;
    this.numFileId = other.numFileId;
    this.RCount = other.RCount;
    this.record = other.record;
    this.regionNowait = other.regionNowait;
    this.regionWait = other.regionWait;
    this.regSize = other.regSize;
    this.SCount = other.SCount;
    this.version = other.version;
    this.WBytes = other.WBytes;
    this.wcBytes = other.wcBytes;
    this.wcMbytes = other.wcMbytes;
    this.WMbytes = other.WMbytes;
    this.WCount = other.WCount;
    this.WCountFill = other.WCountFill;
  }

  public TLogStat deepCopy() {
    return new TLogStat(this);
  }

  @Override
  public void clear() {
    setCurFileIsSet(false);
    this.curFile = 0;
    setCurOffsetIsSet(false);
    this.curOffset = 0;
    setDiskFileIsSet(false);
    this.diskFile = 0;
    setDiskOffsetIsSet(false);
    this.diskOffset = 0;
    setFileidInitIsSet(false);
    this.fileidInit = 0;
    setLgBSizeIsSet(false);
    this.lgBSize = 0;
    setLgSizeIsSet(false);
    this.lgSize = 0;
    setMagicIsSet(false);
    this.magic = 0;
    setMaxCommitperflushIsSet(false);
    this.maxCommitperflush = 0;
    setMaxNfileIdIsSet(false);
    this.maxNfileId = 0;
    setMinCommitperflushIsSet(false);
    this.minCommitperflush = 0;
    setModeIsSet(false);
    this.mode = 0;
    setNumFileIdIsSet(false);
    this.numFileId = 0;
    setRCountIsSet(false);
    this.RCount = 0;
    setRecordIsSet(false);
    this.record = 0;
    setRegionNowaitIsSet(false);
    this.regionNowait = 0;
    setRegionWaitIsSet(false);
    this.regionWait = 0;
    setRegSizeIsSet(false);
    this.regSize = 0;
    setSCountIsSet(false);
    this.SCount = 0;
    setVersionIsSet(false);
    this.version = 0;
    setWBytesIsSet(false);
    this.WBytes = 0;
    setWcBytesIsSet(false);
    this.wcBytes = 0;
    setWcMbytesIsSet(false);
    this.wcMbytes = 0;
    setWMbytesIsSet(false);
    this.WMbytes = 0;
    setWCountIsSet(false);
    this.WCount = 0;
    setWCountFillIsSet(false);
    this.WCountFill = 0;
  }

  public int getCurFile() {
    return this.curFile;
  }

  public TLogStat setCurFile(int curFile) {
    this.curFile = curFile;
    setCurFileIsSet(true);
    return this;
  }

  public void unsetCurFile() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __CURFILE_ISSET_ID);
  }

  /** Returns true if field curFile is set (has been assigned a value) and false otherwise */
  public boolean isSetCurFile() {
    return EncodingUtils.testBit(__isset_bitfield, __CURFILE_ISSET_ID);
  }

  public void setCurFileIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __CURFILE_ISSET_ID, value);
  }

  public int getCurOffset() {
    return this.curOffset;
  }

  public TLogStat setCurOffset(int curOffset) {
    this.curOffset = curOffset;
    setCurOffsetIsSet(true);
    return this;
  }

  public void unsetCurOffset() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __CUROFFSET_ISSET_ID);
  }

  /** Returns true if field curOffset is set (has been assigned a value) and false otherwise */
  public boolean isSetCurOffset() {
    return EncodingUtils.testBit(__isset_bitfield, __CUROFFSET_ISSET_ID);
  }

  public void setCurOffsetIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __CUROFFSET_ISSET_ID, value);
  }

  public int getDiskFile() {
    return this.diskFile;
  }

  public TLogStat setDiskFile(int diskFile) {
    this.diskFile = diskFile;
    setDiskFileIsSet(true);
    return this;
  }

  public void unsetDiskFile() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __DISKFILE_ISSET_ID);
  }

  /** Returns true if field diskFile is set (has been assigned a value) and false otherwise */
  public boolean isSetDiskFile() {
    return EncodingUtils.testBit(__isset_bitfield, __DISKFILE_ISSET_ID);
  }

  public void setDiskFileIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __DISKFILE_ISSET_ID, value);
  }

  public int getDiskOffset() {
    return this.diskOffset;
  }

  public TLogStat setDiskOffset(int diskOffset) {
    this.diskOffset = diskOffset;
    setDiskOffsetIsSet(true);
    return this;
  }

  public void unsetDiskOffset() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __DISKOFFSET_ISSET_ID);
  }

  /** Returns true if field diskOffset is set (has been assigned a value) and false otherwise */
  public boolean isSetDiskOffset() {
    return EncodingUtils.testBit(__isset_bitfield, __DISKOFFSET_ISSET_ID);
  }

  public void setDiskOffsetIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __DISKOFFSET_ISSET_ID, value);
  }

  public int getFileidInit() {
    return this.fileidInit;
  }

  public TLogStat setFileidInit(int fileidInit) {
    this.fileidInit = fileidInit;
    setFileidInitIsSet(true);
    return this;
  }

  public void unsetFileidInit() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __FILEIDINIT_ISSET_ID);
  }

  /** Returns true if field fileidInit is set (has been assigned a value) and false otherwise */
  public boolean isSetFileidInit() {
    return EncodingUtils.testBit(__isset_bitfield, __FILEIDINIT_ISSET_ID);
  }

  public void setFileidInitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __FILEIDINIT_ISSET_ID, value);
  }

  public int getLgBSize() {
    return this.lgBSize;
  }

  public TLogStat setLgBSize(int lgBSize) {
    this.lgBSize = lgBSize;
    setLgBSizeIsSet(true);
    return this;
  }

  public void unsetLgBSize() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __LGBSIZE_ISSET_ID);
  }

  /** Returns true if field lgBSize is set (has been assigned a value) and false otherwise */
  public boolean isSetLgBSize() {
    return EncodingUtils.testBit(__isset_bitfield, __LGBSIZE_ISSET_ID);
  }

  public void setLgBSizeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __LGBSIZE_ISSET_ID, value);
  }

  public int getLgSize() {
    return this.lgSize;
  }

  public TLogStat setLgSize(int lgSize) {
    this.lgSize = lgSize;
    setLgSizeIsSet(true);
    return this;
  }

  public void unsetLgSize() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __LGSIZE_ISSET_ID);
  }

  /** Returns true if field lgSize is set (has been assigned a value) and false otherwise */
  public boolean isSetLgSize() {
    return EncodingUtils.testBit(__isset_bitfield, __LGSIZE_ISSET_ID);
  }

  public void setLgSizeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __LGSIZE_ISSET_ID, value);
  }

  public int getMagic() {
    return this.magic;
  }

  public TLogStat setMagic(int magic) {
    this.magic = magic;
    setMagicIsSet(true);
    return this;
  }

  public void unsetMagic() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MAGIC_ISSET_ID);
  }

  /** Returns true if field magic is set (has been assigned a value) and false otherwise */
  public boolean isSetMagic() {
    return EncodingUtils.testBit(__isset_bitfield, __MAGIC_ISSET_ID);
  }

  public void setMagicIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MAGIC_ISSET_ID, value);
  }

  public int getMaxCommitperflush() {
    return this.maxCommitperflush;
  }

  public TLogStat setMaxCommitperflush(int maxCommitperflush) {
    this.maxCommitperflush = maxCommitperflush;
    setMaxCommitperflushIsSet(true);
    return this;
  }

  public void unsetMaxCommitperflush() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MAXCOMMITPERFLUSH_ISSET_ID);
  }

  /** Returns true if field maxCommitperflush is set (has been assigned a value) and false otherwise */
  public boolean isSetMaxCommitperflush() {
    return EncodingUtils.testBit(__isset_bitfield, __MAXCOMMITPERFLUSH_ISSET_ID);
  }

  public void setMaxCommitperflushIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MAXCOMMITPERFLUSH_ISSET_ID, value);
  }

  public int getMaxNfileId() {
    return this.maxNfileId;
  }

  public TLogStat setMaxNfileId(int maxNfileId) {
    this.maxNfileId = maxNfileId;
    setMaxNfileIdIsSet(true);
    return this;
  }

  public void unsetMaxNfileId() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MAXNFILEID_ISSET_ID);
  }

  /** Returns true if field maxNfileId is set (has been assigned a value) and false otherwise */
  public boolean isSetMaxNfileId() {
    return EncodingUtils.testBit(__isset_bitfield, __MAXNFILEID_ISSET_ID);
  }

  public void setMaxNfileIdIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MAXNFILEID_ISSET_ID, value);
  }

  public int getMinCommitperflush() {
    return this.minCommitperflush;
  }

  public TLogStat setMinCommitperflush(int minCommitperflush) {
    this.minCommitperflush = minCommitperflush;
    setMinCommitperflushIsSet(true);
    return this;
  }

  public void unsetMinCommitperflush() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MINCOMMITPERFLUSH_ISSET_ID);
  }

  /** Returns true if field minCommitperflush is set (has been assigned a value) and false otherwise */
  public boolean isSetMinCommitperflush() {
    return EncodingUtils.testBit(__isset_bitfield, __MINCOMMITPERFLUSH_ISSET_ID);
  }

  public void setMinCommitperflushIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MINCOMMITPERFLUSH_ISSET_ID, value);
  }

  public int getMode() {
    return this.mode;
  }

  public TLogStat setMode(int mode) {
    this.mode = mode;
    setModeIsSet(true);
    return this;
  }

  public void unsetMode() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MODE_ISSET_ID);
  }

  /** Returns true if field mode is set (has been assigned a value) and false otherwise */
  public boolean isSetMode() {
    return EncodingUtils.testBit(__isset_bitfield, __MODE_ISSET_ID);
  }

  public void setModeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MODE_ISSET_ID, value);
  }

  public int getNumFileId() {
    return this.numFileId;
  }

  public TLogStat setNumFileId(int numFileId) {
    this.numFileId = numFileId;
    setNumFileIdIsSet(true);
    return this;
  }

  public void unsetNumFileId() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __NUMFILEID_ISSET_ID);
  }

  /** Returns true if field numFileId is set (has been assigned a value) and false otherwise */
  public boolean isSetNumFileId() {
    return EncodingUtils.testBit(__isset_bitfield, __NUMFILEID_ISSET_ID);
  }

  public void setNumFileIdIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __NUMFILEID_ISSET_ID, value);
  }

  public long getRCount() {
    return this.RCount;
  }

  public TLogStat setRCount(long RCount) {
    this.RCount = RCount;
    setRCountIsSet(true);
    return this;
  }

  public void unsetRCount() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __RCOUNT_ISSET_ID);
  }

  /** Returns true if field RCount is set (has been assigned a value) and false otherwise */
  public boolean isSetRCount() {
    return EncodingUtils.testBit(__isset_bitfield, __RCOUNT_ISSET_ID);
  }

  public void setRCountIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __RCOUNT_ISSET_ID, value);
  }

  public long getRecord() {
    return this.record;
  }

  public TLogStat setRecord(long record) {
    this.record = record;
    setRecordIsSet(true);
    return this;
  }

  public void unsetRecord() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __RECORD_ISSET_ID);
  }

  /** Returns true if field record is set (has been assigned a value) and false otherwise */
  public boolean isSetRecord() {
    return EncodingUtils.testBit(__isset_bitfield, __RECORD_ISSET_ID);
  }

  public void setRecordIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __RECORD_ISSET_ID, value);
  }

  public long getRegionNowait() {
    return this.regionNowait;
  }

  public TLogStat setRegionNowait(long regionNowait) {
    this.regionNowait = regionNowait;
    setRegionNowaitIsSet(true);
    return this;
  }

  public void unsetRegionNowait() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __REGIONNOWAIT_ISSET_ID);
  }

  /** Returns true if field regionNowait is set (has been assigned a value) and false otherwise */
  public boolean isSetRegionNowait() {
    return EncodingUtils.testBit(__isset_bitfield, __REGIONNOWAIT_ISSET_ID);
  }

  public void setRegionNowaitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __REGIONNOWAIT_ISSET_ID, value);
  }

  public long getRegionWait() {
    return this.regionWait;
  }

  public TLogStat setRegionWait(long regionWait) {
    this.regionWait = regionWait;
    setRegionWaitIsSet(true);
    return this;
  }

  public void unsetRegionWait() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __REGIONWAIT_ISSET_ID);
  }

  /** Returns true if field regionWait is set (has been assigned a value) and false otherwise */
  public boolean isSetRegionWait() {
    return EncodingUtils.testBit(__isset_bitfield, __REGIONWAIT_ISSET_ID);
  }

  public void setRegionWaitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __REGIONWAIT_ISSET_ID, value);
  }

  public long getRegSize() {
    return this.regSize;
  }

  public TLogStat setRegSize(long regSize) {
    this.regSize = regSize;
    setRegSizeIsSet(true);
    return this;
  }

  public void unsetRegSize() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __REGSIZE_ISSET_ID);
  }

  /** Returns true if field regSize is set (has been assigned a value) and false otherwise */
  public boolean isSetRegSize() {
    return EncodingUtils.testBit(__isset_bitfield, __REGSIZE_ISSET_ID);
  }

  public void setRegSizeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __REGSIZE_ISSET_ID, value);
  }

  public long getSCount() {
    return this.SCount;
  }

  public TLogStat setSCount(long SCount) {
    this.SCount = SCount;
    setSCountIsSet(true);
    return this;
  }

  public void unsetSCount() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SCOUNT_ISSET_ID);
  }

  /** Returns true if field SCount is set (has been assigned a value) and false otherwise */
  public boolean isSetSCount() {
    return EncodingUtils.testBit(__isset_bitfield, __SCOUNT_ISSET_ID);
  }

  public void setSCountIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SCOUNT_ISSET_ID, value);
  }

  public int getVersion() {
    return this.version;
  }

  public TLogStat setVersion(int version) {
    this.version = version;
    setVersionIsSet(true);
    return this;
  }

  public void unsetVersion() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __VERSION_ISSET_ID);
  }

  /** Returns true if field version is set (has been assigned a value) and false otherwise */
  public boolean isSetVersion() {
    return EncodingUtils.testBit(__isset_bitfield, __VERSION_ISSET_ID);
  }

  public void setVersionIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __VERSION_ISSET_ID, value);
  }

  public int getWBytes() {
    return this.WBytes;
  }

  public TLogStat setWBytes(int WBytes) {
    this.WBytes = WBytes;
    setWBytesIsSet(true);
    return this;
  }

  public void unsetWBytes() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __WBYTES_ISSET_ID);
  }

  /** Returns true if field WBytes is set (has been assigned a value) and false otherwise */
  public boolean isSetWBytes() {
    return EncodingUtils.testBit(__isset_bitfield, __WBYTES_ISSET_ID);
  }

  public void setWBytesIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __WBYTES_ISSET_ID, value);
  }

  public int getWcBytes() {
    return this.wcBytes;
  }

  public TLogStat setWcBytes(int wcBytes) {
    this.wcBytes = wcBytes;
    setWcBytesIsSet(true);
    return this;
  }

  public void unsetWcBytes() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __WCBYTES_ISSET_ID);
  }

  /** Returns true if field wcBytes is set (has been assigned a value) and false otherwise */
  public boolean isSetWcBytes() {
    return EncodingUtils.testBit(__isset_bitfield, __WCBYTES_ISSET_ID);
  }

  public void setWcBytesIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __WCBYTES_ISSET_ID, value);
  }

  public int getWcMbytes() {
    return this.wcMbytes;
  }

  public TLogStat setWcMbytes(int wcMbytes) {
    this.wcMbytes = wcMbytes;
    setWcMbytesIsSet(true);
    return this;
  }

  public void unsetWcMbytes() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __WCMBYTES_ISSET_ID);
  }

  /** Returns true if field wcMbytes is set (has been assigned a value) and false otherwise */
  public boolean isSetWcMbytes() {
    return EncodingUtils.testBit(__isset_bitfield, __WCMBYTES_ISSET_ID);
  }

  public void setWcMbytesIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __WCMBYTES_ISSET_ID, value);
  }

  public int getWMbytes() {
    return this.WMbytes;
  }

  public TLogStat setWMbytes(int WMbytes) {
    this.WMbytes = WMbytes;
    setWMbytesIsSet(true);
    return this;
  }

  public void unsetWMbytes() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __WMBYTES_ISSET_ID);
  }

  /** Returns true if field WMbytes is set (has been assigned a value) and false otherwise */
  public boolean isSetWMbytes() {
    return EncodingUtils.testBit(__isset_bitfield, __WMBYTES_ISSET_ID);
  }

  public void setWMbytesIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __WMBYTES_ISSET_ID, value);
  }

  public long getWCount() {
    return this.WCount;
  }

  public TLogStat setWCount(long WCount) {
    this.WCount = WCount;
    setWCountIsSet(true);
    return this;
  }

  public void unsetWCount() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __WCOUNT_ISSET_ID);
  }

  /** Returns true if field WCount is set (has been assigned a value) and false otherwise */
  public boolean isSetWCount() {
    return EncodingUtils.testBit(__isset_bitfield, __WCOUNT_ISSET_ID);
  }

  public void setWCountIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __WCOUNT_ISSET_ID, value);
  }

  public long getWCountFill() {
    return this.WCountFill;
  }

  public TLogStat setWCountFill(long WCountFill) {
    this.WCountFill = WCountFill;
    setWCountFillIsSet(true);
    return this;
  }

  public void unsetWCountFill() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __WCOUNTFILL_ISSET_ID);
  }

  /** Returns true if field WCountFill is set (has been assigned a value) and false otherwise */
  public boolean isSetWCountFill() {
    return EncodingUtils.testBit(__isset_bitfield, __WCOUNTFILL_ISSET_ID);
  }

  public void setWCountFillIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __WCOUNTFILL_ISSET_ID, value);
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case CUR_FILE:
      if (value == null) {
        unsetCurFile();
      } else {
        setCurFile((Integer)value);
      }
      break;

    case CUR_OFFSET:
      if (value == null) {
        unsetCurOffset();
      } else {
        setCurOffset((Integer)value);
      }
      break;

    case DISK_FILE:
      if (value == null) {
        unsetDiskFile();
      } else {
        setDiskFile((Integer)value);
      }
      break;

    case DISK_OFFSET:
      if (value == null) {
        unsetDiskOffset();
      } else {
        setDiskOffset((Integer)value);
      }
      break;

    case FILEID_INIT:
      if (value == null) {
        unsetFileidInit();
      } else {
        setFileidInit((Integer)value);
      }
      break;

    case LG_BSIZE:
      if (value == null) {
        unsetLgBSize();
      } else {
        setLgBSize((Integer)value);
      }
      break;

    case LG_SIZE:
      if (value == null) {
        unsetLgSize();
      } else {
        setLgSize((Integer)value);
      }
      break;

    case MAGIC:
      if (value == null) {
        unsetMagic();
      } else {
        setMagic((Integer)value);
      }
      break;

    case MAX_COMMITPERFLUSH:
      if (value == null) {
        unsetMaxCommitperflush();
      } else {
        setMaxCommitperflush((Integer)value);
      }
      break;

    case MAX_NFILE_ID:
      if (value == null) {
        unsetMaxNfileId();
      } else {
        setMaxNfileId((Integer)value);
      }
      break;

    case MIN_COMMITPERFLUSH:
      if (value == null) {
        unsetMinCommitperflush();
      } else {
        setMinCommitperflush((Integer)value);
      }
      break;

    case MODE:
      if (value == null) {
        unsetMode();
      } else {
        setMode((Integer)value);
      }
      break;

    case NUM_FILE_ID:
      if (value == null) {
        unsetNumFileId();
      } else {
        setNumFileId((Integer)value);
      }
      break;

    case RCOUNT:
      if (value == null) {
        unsetRCount();
      } else {
        setRCount((Long)value);
      }
      break;

    case RECORD:
      if (value == null) {
        unsetRecord();
      } else {
        setRecord((Long)value);
      }
      break;

    case REGION_NOWAIT:
      if (value == null) {
        unsetRegionNowait();
      } else {
        setRegionNowait((Long)value);
      }
      break;

    case REGION_WAIT:
      if (value == null) {
        unsetRegionWait();
      } else {
        setRegionWait((Long)value);
      }
      break;

    case REG_SIZE:
      if (value == null) {
        unsetRegSize();
      } else {
        setRegSize((Long)value);
      }
      break;

    case SCOUNT:
      if (value == null) {
        unsetSCount();
      } else {
        setSCount((Long)value);
      }
      break;

    case VERSION:
      if (value == null) {
        unsetVersion();
      } else {
        setVersion((Integer)value);
      }
      break;

    case WBYTES:
      if (value == null) {
        unsetWBytes();
      } else {
        setWBytes((Integer)value);
      }
      break;

    case WC_BYTES:
      if (value == null) {
        unsetWcBytes();
      } else {
        setWcBytes((Integer)value);
      }
      break;

    case WC_MBYTES:
      if (value == null) {
        unsetWcMbytes();
      } else {
        setWcMbytes((Integer)value);
      }
      break;

    case WMBYTES:
      if (value == null) {
        unsetWMbytes();
      } else {
        setWMbytes((Integer)value);
      }
      break;

    case WCOUNT:
      if (value == null) {
        unsetWCount();
      } else {
        setWCount((Long)value);
      }
      break;

    case WCOUNT_FILL:
      if (value == null) {
        unsetWCountFill();
      } else {
        setWCountFill((Long)value);
      }
      break;

    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case CUR_FILE:
      return Integer.valueOf(getCurFile());

    case CUR_OFFSET:
      return Integer.valueOf(getCurOffset());

    case DISK_FILE:
      return Integer.valueOf(getDiskFile());

    case DISK_OFFSET:
      return Integer.valueOf(getDiskOffset());

    case FILEID_INIT:
      return Integer.valueOf(getFileidInit());

    case LG_BSIZE:
      return Integer.valueOf(getLgBSize());

    case LG_SIZE:
      return Integer.valueOf(getLgSize());

    case MAGIC:
      return Integer.valueOf(getMagic());

    case MAX_COMMITPERFLUSH:
      return Integer.valueOf(getMaxCommitperflush());

    case MAX_NFILE_ID:
      return Integer.valueOf(getMaxNfileId());

    case MIN_COMMITPERFLUSH:
      return Integer.valueOf(getMinCommitperflush());

    case MODE:
      return Integer.valueOf(getMode());

    case NUM_FILE_ID:
      return Integer.valueOf(getNumFileId());

    case RCOUNT:
      return Long.valueOf(getRCount());

    case RECORD:
      return Long.valueOf(getRecord());

    case REGION_NOWAIT:
      return Long.valueOf(getRegionNowait());

    case REGION_WAIT:
      return Long.valueOf(getRegionWait());

    case REG_SIZE:
      return Long.valueOf(getRegSize());

    case SCOUNT:
      return Long.valueOf(getSCount());

    case VERSION:
      return Integer.valueOf(getVersion());

    case WBYTES:
      return Integer.valueOf(getWBytes());

    case WC_BYTES:
      return Integer.valueOf(getWcBytes());

    case WC_MBYTES:
      return Integer.valueOf(getWcMbytes());

    case WMBYTES:
      return Integer.valueOf(getWMbytes());

    case WCOUNT:
      return Long.valueOf(getWCount());

    case WCOUNT_FILL:
      return Long.valueOf(getWCountFill());

    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case CUR_FILE:
      return isSetCurFile();
    case CUR_OFFSET:
      return isSetCurOffset();
    case DISK_FILE:
      return isSetDiskFile();
    case DISK_OFFSET:
      return isSetDiskOffset();
    case FILEID_INIT:
      return isSetFileidInit();
    case LG_BSIZE:
      return isSetLgBSize();
    case LG_SIZE:
      return isSetLgSize();
    case MAGIC:
      return isSetMagic();
    case MAX_COMMITPERFLUSH:
      return isSetMaxCommitperflush();
    case MAX_NFILE_ID:
      return isSetMaxNfileId();
    case MIN_COMMITPERFLUSH:
      return isSetMinCommitperflush();
    case MODE:
      return isSetMode();
    case NUM_FILE_ID:
      return isSetNumFileId();
    case RCOUNT:
      return isSetRCount();
    case RECORD:
      return isSetRecord();
    case REGION_NOWAIT:
      return isSetRegionNowait();
    case REGION_WAIT:
      return isSetRegionWait();
    case REG_SIZE:
      return isSetRegSize();
    case SCOUNT:
      return isSetSCount();
    case VERSION:
      return isSetVersion();
    case WBYTES:
      return isSetWBytes();
    case WC_BYTES:
      return isSetWcBytes();
    case WC_MBYTES:
      return isSetWcMbytes();
    case WMBYTES:
      return isSetWMbytes();
    case WCOUNT:
      return isSetWCount();
    case WCOUNT_FILL:
      return isSetWCountFill();
    }
    throw new IllegalStateException();
  }

  @Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof TLogStat)
      return this.equals((TLogStat)that);
    return false;
  }

  public boolean equals(TLogStat that) {
    if (that == null)
      return false;

    boolean this_present_curFile = true;
    boolean that_present_curFile = true;
    if (this_present_curFile || that_present_curFile) {
      if (!(this_present_curFile && that_present_curFile))
        return false;
      if (this.curFile != that.curFile)
        return false;
    }

    boolean this_present_curOffset = true;
    boolean that_present_curOffset = true;
    if (this_present_curOffset || that_present_curOffset) {
      if (!(this_present_curOffset && that_present_curOffset))
        return false;
      if (this.curOffset != that.curOffset)
        return false;
    }

    boolean this_present_diskFile = true;
    boolean that_present_diskFile = true;
    if (this_present_diskFile || that_present_diskFile) {
      if (!(this_present_diskFile && that_present_diskFile))
        return false;
      if (this.diskFile != that.diskFile)
        return false;
    }

    boolean this_present_diskOffset = true;
    boolean that_present_diskOffset = true;
    if (this_present_diskOffset || that_present_diskOffset) {
      if (!(this_present_diskOffset && that_present_diskOffset))
        return false;
      if (this.diskOffset != that.diskOffset)
        return false;
    }

    boolean this_present_fileidInit = true;
    boolean that_present_fileidInit = true;
    if (this_present_fileidInit || that_present_fileidInit) {
      if (!(this_present_fileidInit && that_present_fileidInit))
        return false;
      if (this.fileidInit != that.fileidInit)
        return false;
    }

    boolean this_present_lgBSize = true;
    boolean that_present_lgBSize = true;
    if (this_present_lgBSize || that_present_lgBSize) {
      if (!(this_present_lgBSize && that_present_lgBSize))
        return false;
      if (this.lgBSize != that.lgBSize)
        return false;
    }

    boolean this_present_lgSize = true;
    boolean that_present_lgSize = true;
    if (this_present_lgSize || that_present_lgSize) {
      if (!(this_present_lgSize && that_present_lgSize))
        return false;
      if (this.lgSize != that.lgSize)
        return false;
    }

    boolean this_present_magic = true;
    boolean that_present_magic = true;
    if (this_present_magic || that_present_magic) {
      if (!(this_present_magic && that_present_magic))
        return false;
      if (this.magic != that.magic)
        return false;
    }

    boolean this_present_maxCommitperflush = true;
    boolean that_present_maxCommitperflush = true;
    if (this_present_maxCommitperflush || that_present_maxCommitperflush) {
      if (!(this_present_maxCommitperflush && that_present_maxCommitperflush))
        return false;
      if (this.maxCommitperflush != that.maxCommitperflush)
        return false;
    }

    boolean this_present_maxNfileId = true;
    boolean that_present_maxNfileId = true;
    if (this_present_maxNfileId || that_present_maxNfileId) {
      if (!(this_present_maxNfileId && that_present_maxNfileId))
        return false;
      if (this.maxNfileId != that.maxNfileId)
        return false;
    }

    boolean this_present_minCommitperflush = true;
    boolean that_present_minCommitperflush = true;
    if (this_present_minCommitperflush || that_present_minCommitperflush) {
      if (!(this_present_minCommitperflush && that_present_minCommitperflush))
        return false;
      if (this.minCommitperflush != that.minCommitperflush)
        return false;
    }

    boolean this_present_mode = true;
    boolean that_present_mode = true;
    if (this_present_mode || that_present_mode) {
      if (!(this_present_mode && that_present_mode))
        return false;
      if (this.mode != that.mode)
        return false;
    }

    boolean this_present_numFileId = true;
    boolean that_present_numFileId = true;
    if (this_present_numFileId || that_present_numFileId) {
      if (!(this_present_numFileId && that_present_numFileId))
        return false;
      if (this.numFileId != that.numFileId)
        return false;
    }

    boolean this_present_RCount = true;
    boolean that_present_RCount = true;
    if (this_present_RCount || that_present_RCount) {
      if (!(this_present_RCount && that_present_RCount))
        return false;
      if (this.RCount != that.RCount)
        return false;
    }

    boolean this_present_record = true;
    boolean that_present_record = true;
    if (this_present_record || that_present_record) {
      if (!(this_present_record && that_present_record))
        return false;
      if (this.record != that.record)
        return false;
    }

    boolean this_present_regionNowait = true;
    boolean that_present_regionNowait = true;
    if (this_present_regionNowait || that_present_regionNowait) {
      if (!(this_present_regionNowait && that_present_regionNowait))
        return false;
      if (this.regionNowait != that.regionNowait)
        return false;
    }

    boolean this_present_regionWait = true;
    boolean that_present_regionWait = true;
    if (this_present_regionWait || that_present_regionWait) {
      if (!(this_present_regionWait && that_present_regionWait))
        return false;
      if (this.regionWait != that.regionWait)
        return false;
    }

    boolean this_present_regSize = true;
    boolean that_present_regSize = true;
    if (this_present_regSize || that_present_regSize) {
      if (!(this_present_regSize && that_present_regSize))
        return false;
      if (this.regSize != that.regSize)
        return false;
    }

    boolean this_present_SCount = true;
    boolean that_present_SCount = true;
    if (this_present_SCount || that_present_SCount) {
      if (!(this_present_SCount && that_present_SCount))
        return false;
      if (this.SCount != that.SCount)
        return false;
    }

    boolean this_present_version = true;
    boolean that_present_version = true;
    if (this_present_version || that_present_version) {
      if (!(this_present_version && that_present_version))
        return false;
      if (this.version != that.version)
        return false;
    }

    boolean this_present_WBytes = true;
    boolean that_present_WBytes = true;
    if (this_present_WBytes || that_present_WBytes) {
      if (!(this_present_WBytes && that_present_WBytes))
        return false;
      if (this.WBytes != that.WBytes)
        return false;
    }

    boolean this_present_wcBytes = true;
    boolean that_present_wcBytes = true;
    if (this_present_wcBytes || that_present_wcBytes) {
      if (!(this_present_wcBytes && that_present_wcBytes))
        return false;
      if (this.wcBytes != that.wcBytes)
        return false;
    }

    boolean this_present_wcMbytes = true;
    boolean that_present_wcMbytes = true;
    if (this_present_wcMbytes || that_present_wcMbytes) {
      if (!(this_present_wcMbytes && that_present_wcMbytes))
        return false;
      if (this.wcMbytes != that.wcMbytes)
        return false;
    }

    boolean this_present_WMbytes = true;
    boolean that_present_WMbytes = true;
    if (this_present_WMbytes || that_present_WMbytes) {
      if (!(this_present_WMbytes && that_present_WMbytes))
        return false;
      if (this.WMbytes != that.WMbytes)
        return false;
    }

    boolean this_present_WCount = true;
    boolean that_present_WCount = true;
    if (this_present_WCount || that_present_WCount) {
      if (!(this_present_WCount && that_present_WCount))
        return false;
      if (this.WCount != that.WCount)
        return false;
    }

    boolean this_present_WCountFill = true;
    boolean that_present_WCountFill = true;
    if (this_present_WCountFill || that_present_WCountFill) {
      if (!(this_present_WCountFill && that_present_WCountFill))
        return false;
      if (this.WCountFill != that.WCountFill)
        return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    List<Object> list = new ArrayList<Object>();

    boolean present_curFile = true;
    list.add(present_curFile);
    if (present_curFile)
      list.add(curFile);

    boolean present_curOffset = true;
    list.add(present_curOffset);
    if (present_curOffset)
      list.add(curOffset);

    boolean present_diskFile = true;
    list.add(present_diskFile);
    if (present_diskFile)
      list.add(diskFile);

    boolean present_diskOffset = true;
    list.add(present_diskOffset);
    if (present_diskOffset)
      list.add(diskOffset);

    boolean present_fileidInit = true;
    list.add(present_fileidInit);
    if (present_fileidInit)
      list.add(fileidInit);

    boolean present_lgBSize = true;
    list.add(present_lgBSize);
    if (present_lgBSize)
      list.add(lgBSize);

    boolean present_lgSize = true;
    list.add(present_lgSize);
    if (present_lgSize)
      list.add(lgSize);

    boolean present_magic = true;
    list.add(present_magic);
    if (present_magic)
      list.add(magic);

    boolean present_maxCommitperflush = true;
    list.add(present_maxCommitperflush);
    if (present_maxCommitperflush)
      list.add(maxCommitperflush);

    boolean present_maxNfileId = true;
    list.add(present_maxNfileId);
    if (present_maxNfileId)
      list.add(maxNfileId);

    boolean present_minCommitperflush = true;
    list.add(present_minCommitperflush);
    if (present_minCommitperflush)
      list.add(minCommitperflush);

    boolean present_mode = true;
    list.add(present_mode);
    if (present_mode)
      list.add(mode);

    boolean present_numFileId = true;
    list.add(present_numFileId);
    if (present_numFileId)
      list.add(numFileId);

    boolean present_RCount = true;
    list.add(present_RCount);
    if (present_RCount)
      list.add(RCount);

    boolean present_record = true;
    list.add(present_record);
    if (present_record)
      list.add(record);

    boolean present_regionNowait = true;
    list.add(present_regionNowait);
    if (present_regionNowait)
      list.add(regionNowait);

    boolean present_regionWait = true;
    list.add(present_regionWait);
    if (present_regionWait)
      list.add(regionWait);

    boolean present_regSize = true;
    list.add(present_regSize);
    if (present_regSize)
      list.add(regSize);

    boolean present_SCount = true;
    list.add(present_SCount);
    if (present_SCount)
      list.add(SCount);

    boolean present_version = true;
    list.add(present_version);
    if (present_version)
      list.add(version);

    boolean present_WBytes = true;
    list.add(present_WBytes);
    if (present_WBytes)
      list.add(WBytes);

    boolean present_wcBytes = true;
    list.add(present_wcBytes);
    if (present_wcBytes)
      list.add(wcBytes);

    boolean present_wcMbytes = true;
    list.add(present_wcMbytes);
    if (present_wcMbytes)
      list.add(wcMbytes);

    boolean present_WMbytes = true;
    list.add(present_WMbytes);
    if (present_WMbytes)
      list.add(WMbytes);

    boolean present_WCount = true;
    list.add(present_WCount);
    if (present_WCount)
      list.add(WCount);

    boolean present_WCountFill = true;
    list.add(present_WCountFill);
    if (present_WCountFill)
      list.add(WCountFill);

    return list.hashCode();
  }

  @Override
  public int compareTo(TLogStat other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;

    lastComparison = Boolean.valueOf(isSetCurFile()).compareTo(other.isSetCurFile());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCurFile()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.curFile, other.curFile);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetCurOffset()).compareTo(other.isSetCurOffset());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCurOffset()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.curOffset, other.curOffset);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetDiskFile()).compareTo(other.isSetDiskFile());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetDiskFile()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.diskFile, other.diskFile);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetDiskOffset()).compareTo(other.isSetDiskOffset());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetDiskOffset()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.diskOffset, other.diskOffset);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetFileidInit()).compareTo(other.isSetFileidInit());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetFileidInit()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.fileidInit, other.fileidInit);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetLgBSize()).compareTo(other.isSetLgBSize());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetLgBSize()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.lgBSize, other.lgBSize);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetLgSize()).compareTo(other.isSetLgSize());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetLgSize()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.lgSize, other.lgSize);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMagic()).compareTo(other.isSetMagic());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMagic()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.magic, other.magic);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMaxCommitperflush()).compareTo(other.isSetMaxCommitperflush());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMaxCommitperflush()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.maxCommitperflush, other.maxCommitperflush);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMaxNfileId()).compareTo(other.isSetMaxNfileId());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMaxNfileId()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.maxNfileId, other.maxNfileId);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMinCommitperflush()).compareTo(other.isSetMinCommitperflush());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMinCommitperflush()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.minCommitperflush, other.minCommitperflush);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMode()).compareTo(other.isSetMode());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMode()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.mode, other.mode);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetNumFileId()).compareTo(other.isSetNumFileId());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetNumFileId()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.numFileId, other.numFileId);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRCount()).compareTo(other.isSetRCount());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRCount()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.RCount, other.RCount);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRecord()).compareTo(other.isSetRecord());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRecord()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.record, other.record);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRegionNowait()).compareTo(other.isSetRegionNowait());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRegionNowait()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.regionNowait, other.regionNowait);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRegionWait()).compareTo(other.isSetRegionWait());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRegionWait()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.regionWait, other.regionWait);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRegSize()).compareTo(other.isSetRegSize());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRegSize()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.regSize, other.regSize);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetSCount()).compareTo(other.isSetSCount());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetSCount()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.SCount, other.SCount);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetVersion()).compareTo(other.isSetVersion());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetVersion()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.version, other.version);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetWBytes()).compareTo(other.isSetWBytes());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetWBytes()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.WBytes, other.WBytes);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetWcBytes()).compareTo(other.isSetWcBytes());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetWcBytes()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.wcBytes, other.wcBytes);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetWcMbytes()).compareTo(other.isSetWcMbytes());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetWcMbytes()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.wcMbytes, other.wcMbytes);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetWMbytes()).compareTo(other.isSetWMbytes());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetWMbytes()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.WMbytes, other.WMbytes);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetWCount()).compareTo(other.isSetWCount());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetWCount()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.WCount, other.WCount);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetWCountFill()).compareTo(other.isSetWCountFill());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetWCountFill()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.WCountFill, other.WCountFill);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }

  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
  }

  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("TLogStat(");
    boolean first = true;

    sb.append("curFile:");
    sb.append(this.curFile);
    first = false;
    if (!first) sb.append(", ");
    sb.append("curOffset:");
    sb.append(this.curOffset);
    first = false;
    if (!first) sb.append(", ");
    sb.append("diskFile:");
    sb.append(this.diskFile);
    first = false;
    if (!first) sb.append(", ");
    sb.append("diskOffset:");
    sb.append(this.diskOffset);
    first = false;
    if (!first) sb.append(", ");
    sb.append("fileidInit:");
    sb.append(this.fileidInit);
    first = false;
    if (!first) sb.append(", ");
    sb.append("lgBSize:");
    sb.append(this.lgBSize);
    first = false;
    if (!first) sb.append(", ");
    sb.append("lgSize:");
    sb.append(this.lgSize);
    first = false;
    if (!first) sb.append(", ");
    sb.append("magic:");
    sb.append(this.magic);
    first = false;
    if (!first) sb.append(", ");
    sb.append("maxCommitperflush:");
    sb.append(this.maxCommitperflush);
    first = false;
    if (!first) sb.append(", ");
    sb.append("maxNfileId:");
    sb.append(this.maxNfileId);
    first = false;
    if (!first) sb.append(", ");
    sb.append("minCommitperflush:");
    sb.append(this.minCommitperflush);
    first = false;
    if (!first) sb.append(", ");
    sb.append("mode:");
    sb.append(this.mode);
    first = false;
    if (!first) sb.append(", ");
    sb.append("numFileId:");
    sb.append(this.numFileId);
    first = false;
    if (!first) sb.append(", ");
    sb.append("RCount:");
    sb.append(this.RCount);
    first = false;
    if (!first) sb.append(", ");
    sb.append("record:");
    sb.append(this.record);
    first = false;
    if (!first) sb.append(", ");
    sb.append("regionNowait:");
    sb.append(this.regionNowait);
    first = false;
    if (!first) sb.append(", ");
    sb.append("regionWait:");
    sb.append(this.regionWait);
    first = false;
    if (!first) sb.append(", ");
    sb.append("regSize:");
    sb.append(this.regSize);
    first = false;
    if (!first) sb.append(", ");
    sb.append("SCount:");
    sb.append(this.SCount);
    first = false;
    if (!first) sb.append(", ");
    sb.append("version:");
    sb.append(this.version);
    first = false;
    if (!first) sb.append(", ");
    sb.append("WBytes:");
    sb.append(this.WBytes);
    first = false;
    if (!first) sb.append(", ");
    sb.append("wcBytes:");
    sb.append(this.wcBytes);
    first = false;
    if (!first) sb.append(", ");
    sb.append("wcMbytes:");
    sb.append(this.wcMbytes);
    first = false;
    if (!first) sb.append(", ");
    sb.append("WMbytes:");
    sb.append(this.WMbytes);
    first = false;
    if (!first) sb.append(", ");
    sb.append("WCount:");
    sb.append(this.WCount);
    first = false;
    if (!first) sb.append(", ");
    sb.append("WCountFill:");
    sb.append(this.WCountFill);
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws org.apache.thrift.TException {
    // check for required fields
    // check for sub-struct validity
  }

  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
    try {
      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
    try {
      // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
      __isset_bitfield = 0;
      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private static class TLogStatStandardSchemeFactory implements SchemeFactory {
    public TLogStatStandardScheme getScheme() {
      return new TLogStatStandardScheme();
    }
  }

  private static class TLogStatStandardScheme extends StandardScheme<TLogStat> {

    public void read(org.apache.thrift.protocol.TProtocol iprot, TLogStat struct) throws org.apache.thrift.TException {
      org.apache.thrift.protocol.TField schemeField;
      iprot.readStructBegin();
      while (true)
      {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (schemeField.id) {
          case 1: // CUR_FILE
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.curFile = iprot.readI32();
              struct.setCurFileIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 2: // CUR_OFFSET
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.curOffset = iprot.readI32();
              struct.setCurOffsetIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 3: // DISK_FILE
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.diskFile = iprot.readI32();
              struct.setDiskFileIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 4: // DISK_OFFSET
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.diskOffset = iprot.readI32();
              struct.setDiskOffsetIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 5: // FILEID_INIT
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.fileidInit = iprot.readI32();
              struct.setFileidInitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 6: // LG_BSIZE
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.lgBSize = iprot.readI32();
              struct.setLgBSizeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 7: // LG_SIZE
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.lgSize = iprot.readI32();
              struct.setLgSizeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 8: // MAGIC
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.magic = iprot.readI32();
              struct.setMagicIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 9: // MAX_COMMITPERFLUSH
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.maxCommitperflush = iprot.readI32();
              struct.setMaxCommitperflushIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 10: // MAX_NFILE_ID
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.maxNfileId = iprot.readI32();
              struct.setMaxNfileIdIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 11: // MIN_COMMITPERFLUSH
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.minCommitperflush = iprot.readI32();
              struct.setMinCommitperflushIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 12: // MODE
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.mode = iprot.readI32();
              struct.setModeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 13: // NUM_FILE_ID
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.numFileId = iprot.readI32();
              struct.setNumFileIdIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 14: // RCOUNT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.RCount = iprot.readI64();
              struct.setRCountIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 15: // RECORD
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.record = iprot.readI64();
              struct.setRecordIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 16: // REGION_NOWAIT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.regionNowait = iprot.readI64();
              struct.setRegionNowaitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 17: // REGION_WAIT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.regionWait = iprot.readI64();
              struct.setRegionWaitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 18: // REG_SIZE
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.regSize = iprot.readI64();
              struct.setRegSizeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 19: // SCOUNT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.SCount = iprot.readI64();
              struct.setSCountIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 20: // VERSION
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.version = iprot.readI32();
              struct.setVersionIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 21: // WBYTES
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.WBytes = iprot.readI32();
              struct.setWBytesIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 22: // WC_BYTES
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.wcBytes = iprot.readI32();
              struct.setWcBytesIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 23: // WC_MBYTES
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.wcMbytes = iprot.readI32();
              struct.setWcMbytesIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 24: // WMBYTES
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.WMbytes = iprot.readI32();
              struct.setWMbytesIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 25: // WCOUNT
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.WCount = iprot.readI64();
              struct.setWCountIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 26: // WCOUNT_FILL
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.WCountFill = iprot.readI64();
              struct.setWCountFillIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      struct.validate();
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot, TLogStat struct) throws org.apache.thrift.TException {
      struct.validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(CUR_FILE_FIELD_DESC);
      oprot.writeI32(struct.curFile);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(CUR_OFFSET_FIELD_DESC);
      oprot.writeI32(struct.curOffset);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(DISK_FILE_FIELD_DESC);
      oprot.writeI32(struct.diskFile);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(DISK_OFFSET_FIELD_DESC);
      oprot.writeI32(struct.diskOffset);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(FILEID_INIT_FIELD_DESC);
      oprot.writeI32(struct.fileidInit);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(LG_BSIZE_FIELD_DESC);
      oprot.writeI32(struct.lgBSize);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(LG_SIZE_FIELD_DESC);
      oprot.writeI32(struct.lgSize);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MAGIC_FIELD_DESC);
      oprot.writeI32(struct.magic);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MAX_COMMITPERFLUSH_FIELD_DESC);
      oprot.writeI32(struct.maxCommitperflush);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MAX_NFILE_ID_FIELD_DESC);
      oprot.writeI32(struct.maxNfileId);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MIN_COMMITPERFLUSH_FIELD_DESC);
      oprot.writeI32(struct.minCommitperflush);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MODE_FIELD_DESC);
      oprot.writeI32(struct.mode);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(NUM_FILE_ID_FIELD_DESC);
      oprot.writeI32(struct.numFileId);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(RCOUNT_FIELD_DESC);
      oprot.writeI64(struct.RCount);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(RECORD_FIELD_DESC);
      oprot.writeI64(struct.record);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(REGION_NOWAIT_FIELD_DESC);
      oprot.writeI64(struct.regionNowait);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(REGION_WAIT_FIELD_DESC);
      oprot.writeI64(struct.regionWait);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(REG_SIZE_FIELD_DESC);
      oprot.writeI64(struct.regSize);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(SCOUNT_FIELD_DESC);
      oprot.writeI64(struct.SCount);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(VERSION_FIELD_DESC);
      oprot.writeI32(struct.version);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(WBYTES_FIELD_DESC);
      oprot.writeI32(struct.WBytes);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(WC_BYTES_FIELD_DESC);
      oprot.writeI32(struct.wcBytes);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(WC_MBYTES_FIELD_DESC);
      oprot.writeI32(struct.wcMbytes);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(WMBYTES_FIELD_DESC);
      oprot.writeI32(struct.WMbytes);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(WCOUNT_FIELD_DESC);
      oprot.writeI64(struct.WCount);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(WCOUNT_FILL_FIELD_DESC);
      oprot.writeI64(struct.WCountFill);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

  }

  private static class TLogStatTupleSchemeFactory implements SchemeFactory {
    public TLogStatTupleScheme getScheme() {
      return new TLogStatTupleScheme();
    }
  }

  private static class TLogStatTupleScheme extends TupleScheme<TLogStat> {

    @Override
    public void write(org.apache.thrift.protocol.TProtocol prot, TLogStat struct) throws org.apache.thrift.TException {
      TTupleProtocol oprot = (TTupleProtocol) prot;
      BitSet optionals = new BitSet();
      if (struct.isSetCurFile()) {
        optionals.set(0);
      }
      if (struct.isSetCurOffset()) {
        optionals.set(1);
      }
      if (struct.isSetDiskFile()) {
        optionals.set(2);
      }
      if (struct.isSetDiskOffset()) {
        optionals.set(3);
      }
      if (struct.isSetFileidInit()) {
        optionals.set(4);
      }
      if (struct.isSetLgBSize()) {
        optionals.set(5);
      }
      if (struct.isSetLgSize()) {
        optionals.set(6);
      }
      if (struct.isSetMagic()) {
        optionals.set(7);
      }
      if (struct.isSetMaxCommitperflush()) {
        optionals.set(8);
      }
      if (struct.isSetMaxNfileId()) {
        optionals.set(9);
      }
      if (struct.isSetMinCommitperflush()) {
        optionals.set(10);
      }
      if (struct.isSetMode()) {
        optionals.set(11);
      }
      if (struct.isSetNumFileId()) {
        optionals.set(12);
      }
      if (struct.isSetRCount()) {
        optionals.set(13);
      }
      if (struct.isSetRecord()) {
        optionals.set(14);
      }
      if (struct.isSetRegionNowait()) {
        optionals.set(15);
      }
      if (struct.isSetRegionWait()) {
        optionals.set(16);
      }
      if (struct.isSetRegSize()) {
        optionals.set(17);
      }
      if (struct.isSetSCount()) {
        optionals.set(18);
      }
      if (struct.isSetVersion()) {
        optionals.set(19);
      }
      if (struct.isSetWBytes()) {
        optionals.set(20);
      }
      if (struct.isSetWcBytes()) {
        optionals.set(21);
      }
      if (struct.isSetWcMbytes()) {
        optionals.set(22);
      }
      if (struct.isSetWMbytes()) {
        optionals.set(23);
      }
      if (struct.isSetWCount()) {
        optionals.set(24);
      }
      if (struct.isSetWCountFill()) {
        optionals.set(25);
      }
      oprot.writeBitSet(optionals, 26);
      if (struct.isSetCurFile()) {
        oprot.writeI32(struct.curFile);
      }
      if (struct.isSetCurOffset()) {
        oprot.writeI32(struct.curOffset);
      }
      if (struct.isSetDiskFile()) {
        oprot.writeI32(struct.diskFile);
      }
      if (struct.isSetDiskOffset()) {
        oprot.writeI32(struct.diskOffset);
      }
      if (struct.isSetFileidInit()) {
        oprot.writeI32(struct.fileidInit);
      }
      if (struct.isSetLgBSize()) {
        oprot.writeI32(struct.lgBSize);
      }
      if (struct.isSetLgSize()) {
        oprot.writeI32(struct.lgSize);
      }
      if (struct.isSetMagic()) {
        oprot.writeI32(struct.magic);
      }
      if (struct.isSetMaxCommitperflush()) {
        oprot.writeI32(struct.maxCommitperflush);
      }
      if (struct.isSetMaxNfileId()) {
        oprot.writeI32(struct.maxNfileId);
      }
      if (struct.isSetMinCommitperflush()) {
        oprot.writeI32(struct.minCommitperflush);
      }
      if (struct.isSetMode()) {
        oprot.writeI32(struct.mode);
      }
      if (struct.isSetNumFileId()) {
        oprot.writeI32(struct.numFileId);
      }
      if (struct.isSetRCount()) {
        oprot.writeI64(struct.RCount);
      }
      if (struct.isSetRecord()) {
        oprot.writeI64(struct.record);
      }
      if (struct.isSetRegionNowait()) {
        oprot.writeI64(struct.regionNowait);
      }
      if (struct.isSetRegionWait()) {
        oprot.writeI64(struct.regionWait);
      }
      if (struct.isSetRegSize()) {
        oprot.writeI64(struct.regSize);
      }
      if (struct.isSetSCount()) {
        oprot.writeI64(struct.SCount);
      }
      if (struct.isSetVersion()) {
        oprot.writeI32(struct.version);
      }
      if (struct.isSetWBytes()) {
        oprot.writeI32(struct.WBytes);
      }
      if (struct.isSetWcBytes()) {
        oprot.writeI32(struct.wcBytes);
      }
      if (struct.isSetWcMbytes()) {
        oprot.writeI32(struct.wcMbytes);
      }
      if (struct.isSetWMbytes()) {
        oprot.writeI32(struct.WMbytes);
      }
      if (struct.isSetWCount()) {
        oprot.writeI64(struct.WCount);
      }
      if (struct.isSetWCountFill()) {
        oprot.writeI64(struct.WCountFill);
      }
    }

    @Override
    public void read(org.apache.thrift.protocol.TProtocol prot, TLogStat struct) throws org.apache.thrift.TException {
      TTupleProtocol iprot = (TTupleProtocol) prot;
      BitSet incoming = iprot.readBitSet(26);
      if (incoming.get(0)) {
        struct.curFile = iprot.readI32();
        struct.setCurFileIsSet(true);
      }
      if (incoming.get(1)) {
        struct.curOffset = iprot.readI32();
        struct.setCurOffsetIsSet(true);
      }
      if (incoming.get(2)) {
        struct.diskFile = iprot.readI32();
        struct.setDiskFileIsSet(true);
      }
      if (incoming.get(3)) {
        struct.diskOffset = iprot.readI32();
        struct.setDiskOffsetIsSet(true);
      }
      if (incoming.get(4)) {
        struct.fileidInit = iprot.readI32();
        struct.setFileidInitIsSet(true);
      }
      if (incoming.get(5)) {
        struct.lgBSize = iprot.readI32();
        struct.setLgBSizeIsSet(true);
      }
      if (incoming.get(6)) {
        struct.lgSize = iprot.readI32();
        struct.setLgSizeIsSet(true);
      }
      if (incoming.get(7)) {
        struct.magic = iprot.readI32();
        struct.setMagicIsSet(true);
      }
      if (incoming.get(8)) {
        struct.maxCommitperflush = iprot.readI32();
        struct.setMaxCommitperflushIsSet(true);
      }
      if (incoming.get(9)) {
        struct.maxNfileId = iprot.readI32();
        struct.setMaxNfileIdIsSet(true);
      }
      if (incoming.get(10)) {
        struct.minCommitperflush = iprot.readI32();
        struct.setMinCommitperflushIsSet(true);
      }
      if (incoming.get(11)) {
        struct.mode = iprot.readI32();
        struct.setModeIsSet(true);
      }
      if (incoming.get(12)) {
        struct.numFileId = iprot.readI32();
        struct.setNumFileIdIsSet(true);
      }
      if (incoming.get(13)) {
        struct.RCount = iprot.readI64();
        struct.setRCountIsSet(true);
      }
      if (incoming.get(14)) {
        struct.record = iprot.readI64();
        struct.setRecordIsSet(true);
      }
      if (incoming.get(15)) {
        struct.regionNowait = iprot.readI64();
        struct.setRegionNowaitIsSet(true);
      }
      if (incoming.get(16)) {
        struct.regionWait = iprot.readI64();
        struct.setRegionWaitIsSet(true);
      }
      if (incoming.get(17)) {
        struct.regSize = iprot.readI64();
        struct.setRegSizeIsSet(true);
      }
      if (incoming.get(18)) {
        struct.SCount = iprot.readI64();
        struct.setSCountIsSet(true);
      }
      if (incoming.get(19)) {
        struct.version = iprot.readI32();
        struct.setVersionIsSet(true);
      }
      if (incoming.get(20)) {
        struct.WBytes = iprot.readI32();
        struct.setWBytesIsSet(true);
      }
      if (incoming.get(21)) {
        struct.wcBytes = iprot.readI32();
        struct.setWcBytesIsSet(true);
      }
      if (incoming.get(22)) {
        struct.wcMbytes = iprot.readI32();
        struct.setWcMbytesIsSet(true);
      }
      if (incoming.get(23)) {
        struct.WMbytes = iprot.readI32();
        struct.setWMbytesIsSet(true);
      }
      if (incoming.get(24)) {
        struct.WCount = iprot.readI64();
        struct.setWCountIsSet(true);
      }
      if (incoming.get(25)) {
        struct.WCountFill = iprot.readI64();
        struct.setWCountFillIsSet(true);
      }
    }
  }

}

